{
  
    
        "post0": {
            "title": "Title",
            "content": ". # uncomment to install in colab # !pip install -e git+https://github.com/enzoampil/fastquant.git@master#egg=fastquant . fbprophet . https://facebook.github.io/prophet/docs/quick_start.html | https://nbviewer.jupyter.org/github/nicolasfauchereau/Auckland_Cycling/blob/master/notebooks/Auckland_cycling_and_weather.ipynb | . !pip install fbprophetimport fbprophet fbprophet.__version__ symbol=&quot;JFC&quot; start_date=&quot;2018-01-01&quot; end_date=&quot;2020-04-01&quot; . from fastquant import get_stock_data data = get_stock_data(symbol=symbol, start_date=start_date, end_date=end_date, source=&quot;phisix&quot;, format=&quot;dc&quot;, ) data.columns = &quot;ds y&quot;.split() data.head() . ds y . 1834 2018-01-03 | 255.4 | . 1835 2018-01-04 | 255.0 | . 1836 2018-01-05 | 255.0 | . 1837 2018-01-08 | 256.0 | . 1838 2018-01-09 | 255.8 | . from fastquant import DisclosuresPSE psed = DisclosuresPSE(symbol=symbol, start_date=&quot;01-01-2018&quot;, end_date=&quot;01-04-2020&quot;, ) . Pulling JFC disclosures summary... 2 pages detected! . 0%| | 0/59 [00:00&lt;?, ?it/s] . Found 59 disclosures between 01-01-2018 &amp; 01-04-2020 with 14 types: [&#39;Press Release&#39; &#39;Joint Ventures&#39; &#39;Declaration of Cash Dividends&#39; &#39;Change in Corporate Contact Details and/or Website&#39; &#39;Material Information/Transactions&#39; &#39;Substantial Acquisitions&#39; &#39;Clarification of News Reports&#39; &#34;Results of Annual or Special Stockholders&#39; Meeting&#34; &#39;Results of Organizational Meeting of Board of Directors&#39; &#34;Notice of Annual or Special Stockholders&#39; Meeting&#34; &#39;Acquisition or Disposition of Shares of Another Corporation&#39; &#39;Change in Directors and/or Officers (Resignation, Removal or Appointment, Election and/or Promotion)&#39; &#39;Amendments to By-Laws&#39; &#39;Amendments to Articles of Incorporation&#39;] Pulling details in all JFC disclosures... . 100%|██████████| 59/59 [01:25&lt;00:00, 1.48s/it] . Loaded: /home/jp/github/research/project/fastquant/fastquant/../data/JFC_disclosures_1-1-2020_4-1-2020.csv Deleted: /home/jp/github/research/project/fastquant/fastquant/../data/JFC_disclosures_1-1-2020_4-1-2020.csv Saved: /home/jp/github/research/project/fastquant/fastquant/../data/JFC_disclosures_01-01-2018_01-04-2020.csv . . psed . DisclosuresPSE(&#39;JFC&#39;, &#39;all&#39;, &#39;01-01-2018&#39;, &#39;01-04-2020&#39;, True, True) . from fbprophet import Prophet m = Prophet(growth=&quot;linear&quot;, seasonality_mode=&#39;additive&#39;, daily_seasonality=False, weekly_seasonality=True, yearly_seasonality=True, interval_width=0.95, #uncertainty holidays=None, n_changepoints=20, ) m.add_country_holidays(country_name=&#39;PH&#39;) # m.add_seasonality(name=&#39;monthly&#39;, period=30.5, fourier_order=5) m.fit(data) . Importing plotly failed. Interactive plots will not work. . &lt;fbprophet.forecaster.Prophet at 0x7fa64835d310&gt; . m.train_holiday_names . 0 New Year&#39;s Day 1 Maundy Thursday 2 Good Friday 3 Day of Valor 4 Labor Day 5 Independence Day 6 Eid al-Fitr 7 Feast of the Sacrifice 8 National Heroes&#39; Day 9 Bonifacio Day 10 Christmas Day 11 Rizal Day 12 Day of Valor, Maundy Thursday dtype: object . future = m.make_future_dataframe(periods=28) future.tail() . ds . 570 2020-04-25 | . 571 2020-04-26 | . 572 2020-04-27 | . 573 2020-04-28 | . 574 2020-04-29 | . forecast = m.predict(future) forecast[[&#39;ds&#39;, &#39;yhat&#39;, &#39;yhat_lower&#39;, &#39;yhat_upper&#39;]].tail() . ds yhat yhat_lower yhat_upper . 570 2020-04-25 | 103.177183 | 83.587591 | 121.723567 | . 571 2020-04-26 | 101.433078 | 82.308303 | 120.851018 | . 572 2020-04-27 | 88.637509 | 70.148413 | 108.970685 | . 573 2020-04-28 | 86.705508 | 67.810857 | 104.951139 | . 574 2020-04-29 | 84.994734 | 66.316919 | 105.360896 | . fig1 = m.plot(forecast, uncertainty=True) . from fastquant import datestring_to_datetime fig1 = m.plot(forecast) #zoom fig1.axes[0].set_xlim(datestring_to_datetime(&quot;2020-02-01&quot;), datestring_to_datetime(&quot;2020-04-30&quot;) ) . (737456.0, 737545.0) . fig2 = m.plot_components(forecast) . from fbprophet.plot import add_changepoints_to_plot fig = m.plot(forecast) a = add_changepoints_to_plot(fig.gca(), m, forecast) . fig = psed.plot_disclosures(disclosure_type=&quot;substantial acquisitions&quot;) cp = add_changepoints_to_plot(fig.gca(), m, forecast) . Pulling JFC stock data... . pm-prophet (under development) . https://github.com/luke14free/pm-prophet#installing-pm-prophet | .",
            "url": "https://enzoampil.github.io/fastquant-blog/2020/07/14/prediction_with_prophet.html",
            "relUrl": "/2020/07/14/prediction_with_prophet.html",
            "date": " • Jul 14, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Title",
            "content": ". # uncomment to install in colab # !pip install -e git+https://github.com/enzoampil/fastquant.git@master#egg=fastquant . fetch stock data from yahoo finance . from fastquant import get_yahoo_data #TESLA=TSLA in yahoo finance data = get_yahoo_data(&quot;TSLA&quot;, &quot;2020-01-01&quot;, &quot;2020-07-04&quot;) . [*********************100%***********************] 1 of 1 completed . scrape news from business times website and compute sentiment . from fastquant import get_bt_news_sentiment #scrape the first 3 pages of https://www.businesstimes.com.sg/search/tesla?page=1&amp;filter=headline_en sentiments = get_bt_news_sentiment(keyword=&quot;tesla&quot;, page_nums=3) sentiments . 100%|██████████| 3/3 [02:55&lt;00:00, 55.83s/it] . {datetime.date(2020, 7, 13): -0.95, datetime.date(2020, 7, 11): 0.711, datetime.date(2020, 7, 10): 0.873, datetime.date(2020, 7, 7): 0.966, datetime.date(2020, 7, 4): 0.969, datetime.date(2020, 7, 3): 0.991, datetime.date(2020, 6, 28): 0.21, datetime.date(2020, 6, 13): -0.348, datetime.date(2020, 6, 12): 0.09, datetime.date(2020, 6, 6): 0.923, datetime.date(2020, 6, 5): 0.945, datetime.date(2020, 6, 4): 0.99, datetime.date(2020, 6, 3): 0.952, datetime.date(2020, 5, 30): 0.985, datetime.date(2020, 5, 20): -0.546, datetime.date(2020, 5, 18): -0.345, datetime.date(2020, 5, 16): 0.566, datetime.date(2020, 5, 15): -0.609, datetime.date(2020, 5, 14): 0.287, datetime.date(2020, 5, 13): -0.951, datetime.date(2020, 5, 9): 0.168, datetime.date(2020, 5, 7): 0.769, datetime.date(2020, 5, 3): -0.365, datetime.date(2020, 5, 2): -0.101, datetime.date(2020, 5, 1): 0.216} . run backtest . import matplotlib.pyplot as pl pl.style.use(&quot;default&quot;) . from fastquant import backtest #initiate buy/sell if senti&gt;0.2/senti&lt;-0.2 backtest(&quot;sentiment&quot;, data, sentiments=sentiments, senti=0.2) . Starting Portfolio Value: 100000.00 ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== sentiment threshold : 0.2 2020-05-01, BUY CREATE, 755.00 2020-05-01, Cash: 100000.0 2020-05-01, Price: 755.0 2020-05-01, Buy prop size: 131 2020-05-01, Afforded size: 131 2020-05-01, Final size: 131 2020-05-04, BUY EXECUTED, Price: 755.00, Cost: 98905.00, Comm 741.79 2020-05-13, SELL CREATE, 780.00 2020-05-14, SELL EXECUTED, Price: 780.00, Cost: 98905.00, Comm 766.35 2020-05-14, OPERATION PROFIT, GROSS 3275.00, NET 1766.86 2020-05-14, BUY CREATE, 780.00 2020-05-14, Cash: 101766.86249999999 2020-05-14, Price: 780.0 2020-05-14, Buy prop size: 129 2020-05-14, Afforded size: 129 2020-05-14, Final size: 129 2020-05-15, BUY EXECUTED, Price: 780.00, Cost: 100620.00, Comm 754.65 2020-05-15, SELL CREATE, 827.78 2020-05-18, SELL EXECUTED, Price: 827.78, Cost: 100620.00, Comm 800.88 2020-05-18, OPERATION PROFIT, GROSS 6163.62, NET 4608.10 2020-06-03, BUY CREATE, 888.12 2020-06-03, Cash: 106374.95910095214 2020-06-03, Price: 888.1199951171875 2020-06-03, Buy prop size: 118 2020-06-03, Afforded size: 118 2020-06-03, Final size: 118 2020-06-04, BUY EXECUTED, Price: 888.12, Cost: 104798.16, Comm 785.99 2020-06-12, SELL CREATE, 917.79 2020-06-15, SELL EXECUTED, Price: 917.79, Cost: 104798.16, Comm 812.24 2020-06-15, OPERATION PROFIT, GROSS 3501.06, NET 1902.83 Final PnL: 8277.79 ================================================== Number of strat runs: 1 Number of strats per run: 1 Strat names: [&lt;class &#39;fastquant.strategies.SentimentStrategy&#39;&gt;] ************************************************** -- {&#39;init_cash&#39;: 100000, &#39;buy_prop&#39;: 1, &#39;sell_prop&#39;: 1, &#39;execution_type&#39;: &#39;close&#39;, &#39;senti&#39;: 0.2} OrderedDict([(&#39;rtot&#39;, 0.07952983856127883), (&#39;ravg&#39;, 0.0006213268637599909), (&#39;rnorm&#39;, 0.1694977342426247), (&#39;rnorm100&#39;, 16.94977342426247)]) OrderedDict([(&#39;sharperatio&#39;, 0.7583895238617151)]) Time used (seconds): 0.05083179473876953 Optimal parameters: {&#39;init_cash&#39;: 100000, &#39;buy_prop&#39;: 1, &#39;sell_prop&#39;: 1, &#39;execution_type&#39;: &#39;close&#39;, &#39;senti&#39;: 0.2} Optimal metrics: {&#39;rtot&#39;: 0.07952983856127883, &#39;ravg&#39;: 0.0006213268637599909, &#39;rnorm&#39;: 0.1694977342426247, &#39;rnorm100&#39;: 16.94977342426247, &#39;sharperatio&#39;: 0.7583895238617151, &#39;pnl&#39;: 8277.79, &#39;final_value&#39;: 108277.78675811767} . init_cash buy_prop sell_prop execution_type senti rtot ravg rnorm rnorm100 sharperatio pnl final_value . 0 100000 | 1 | 1 | close | 0.2 | 0.07953 | 0.000621 | 0.169498 | 16.949773 | 0.75839 | 8277.79 | 108277.786758 | .",
            "url": "https://enzoampil.github.io/fastquant-blog/2020/07/14/backtest-news-sentiment.html",
            "relUrl": "/2020/07/14/backtest-news-sentiment.html",
            "date": " • Jul 14, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Title",
            "content": ". # uncomment to install in colab # !pip install -e git+https://github.com/enzoampil/fastquant.git@master#egg=fastquant . Define strategies in a dictionary . from fastquant import backtest, get_stock_data df = get_stock_data(&quot;JFC&quot;, &quot;2018-01-01&quot;, &quot;2019-01-01&quot;) # Utilize single set of parameters strats = { &quot;smac&quot;: {&quot;fast_period&quot;: 35, &quot;slow_period&quot;: 50}, &quot;rsi&quot;: {&quot;rsi_lower&quot;: 30, &quot;rsi_upper&quot;: 70} } res = backtest(&quot;multi&quot;, df, strats=strats) res.shape # (1, 16) . Starting Portfolio Value: 100000.00 ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== fast_period : 35 slow_period : 50 ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== rsi_period : 14 rsi_upper : 70 rsi_lower : 30 2018-07-06, BUY CREATE, 251.00 2018-07-06, Cash: 100000.0 2018-07-06, Price: 251.0 2018-07-06, Buy prop size: 395 2018-07-06, Afforded size: 395 2018-07-06, Final size: 395 2018-07-09, BUY EXECUTED, Price: 251.00, Cost: 99145.00, Comm 743.59 2018-08-01, SELL CREATE, 276.00 2018-08-02, SELL EXECUTED, Price: 276.00, Cost: 99145.00, Comm 817.65 2018-08-02, OPERATION PROFIT, GROSS 9875.00, NET 8313.76 2018-08-29, BUY CREATE, 287.40 2018-08-29, Cash: 108313.76250000001 2018-08-29, Price: 287.4 2018-08-29, Buy prop size: 373 2018-08-29, Afforded size: 373 2018-08-29, Final size: 373 2018-08-30, BUY EXECUTED, Price: 287.40, Cost: 107200.20, Comm 804.00 2018-10-08, SELL CREATE, 252.40 2018-10-08, BUY CREATE, 243.00 2018-10-08, Cash: 309.5610000000147 2018-10-08, Price: 243.0 2018-10-08, Buy prop size: 1 2018-10-08, Afforded size: 1 2018-10-08, Final size: 1 2018-10-09, SELL EXECUTED, Price: 252.40, Cost: 107200.20, Comm 706.09 2018-10-09, OPERATION PROFIT, GROSS -13055.00, NET -14565.09 2018-10-09, BUY EXECUTED, Price: 243.00, Cost: 243.00, Comm 1.82 2018-11-22, BUY CREATE, 285.00 2018-11-22, Cash: 93503.84950000003 2018-11-22, Price: 285.0 2018-11-22, Buy prop size: 325 2018-11-22, Afforded size: 325 2018-11-22, Final size: 325 2018-11-23, BUY EXECUTED, Price: 285.00, Cost: 92625.00, Comm 694.69 2018-12-19, SELL CREATE, 303.00 2018-12-20, SELL EXECUTED, Price: 303.00, Cost: 92868.00, Comm 740.83 Final PnL: -1778.67 Final PnL: -1778.67 ================================================== Number of strat runs: 1 Number of strats per run: 2 Strat names: [&#39;smac&#39;, &#39;rsi&#39;] ************************************************** -- {&#39;init_cash&#39;: 100000, &#39;buy_prop&#39;: 1, &#39;sell_prop&#39;: 1, &#39;execution_type&#39;: &#39;close&#39;, &#39;smac.fast_period&#39;: 35, &#39;smac.slow_period&#39;: 50, &#39;rsi.rsi_period&#39;: 14, &#39;rsi.rsi_upper&#39;: 70, &#39;rsi.rsi_lower&#39;: 30} OrderedDict([(&#39;rtot&#39;, -0.0179468149815959), (&#39;ravg&#39;, -7.385520568557983e-05), (&#39;rnorm&#39;, -0.018439387134145634), (&#39;rnorm100&#39;, -1.8439387134145633)]) OrderedDict([(&#39;sharperatio&#39;, None)]) Time used (seconds): 0.07079172134399414 Optimal parameters: {&#39;init_cash&#39;: 100000, &#39;buy_prop&#39;: 1, &#39;sell_prop&#39;: 1, &#39;execution_type&#39;: &#39;close&#39;, &#39;smac.fast_period&#39;: 35, &#39;smac.slow_period&#39;: 50, &#39;rsi.rsi_period&#39;: 14, &#39;rsi.rsi_upper&#39;: 70, &#39;rsi.rsi_lower&#39;: 30} Optimal metrics: {&#39;rtot&#39;: -0.0179468149815959, &#39;ravg&#39;: -7.385520568557983e-05, &#39;rnorm&#39;: -0.018439387134145634, &#39;rnorm100&#39;: -1.8439387134145633, &#39;sharperatio&#39;: None, &#39;pnl&#39;: -1778.67, &#39;final_value&#39;: 98221.32700000002} . (1, 16) . Utilize auto grid search . strats_opt = { &quot;smac&quot;: {&quot;fast_period&quot;: 35, &quot;slow_period&quot;: [40, 50]}, &quot;rsi&quot;: {&quot;rsi_lower&quot;: [15, 30], &quot;rsi_upper&quot;: 70} } res_opt = backtest(&quot;multi&quot;, df, strats=strats_opt) res_opt.shape # (4, 16) . Starting Portfolio Value: 100000.00 ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== fast_period : 35 slow_period : 40 ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== rsi_period : 14 rsi_upper : 70 rsi_lower : 15 2018-06-01, BUY CREATE, 283.80 2018-06-01, Cash: 100000.0 2018-06-01, Price: 283.8 2018-06-01, Buy prop size: 349 2018-06-01, Afforded size: 349 2018-06-01, Final size: 349 2018-06-04, BUY EXECUTED, Price: 283.80, Cost: 99046.20, Comm 742.85 2018-06-04, SELL CREATE, 280.20 2018-06-05, SELL EXECUTED, Price: 280.20, Cost: 99046.20, Comm 733.42 2018-06-05, OPERATION PROFIT, GROSS -1256.40, NET -2732.67 2018-06-29, BUY CREATE, 263.00 2018-06-29, Cash: 97267.32999999999 2018-06-29, Price: 263.0 2018-06-29, Buy prop size: 366 2018-06-29, Afforded size: 366 2018-06-29, Final size: 366 2018-07-02, BUY EXECUTED, Price: 263.00, Cost: 96258.00, Comm 721.94 2018-07-03, SELL CREATE, 259.80 2018-07-04, SELL EXECUTED, Price: 259.80, Cost: 96258.00, Comm 713.15 2018-07-04, OPERATION PROFIT, GROSS -1171.20, NET -2606.29 2018-08-23, BUY CREATE, 293.00 2018-08-23, Cash: 94661.044 2018-08-23, Price: 293.0 2018-08-23, Buy prop size: 320 2018-08-23, Afforded size: 320 2018-08-23, Final size: 320 2018-08-24, BUY EXECUTED, Price: 293.00, Cost: 93760.00, Comm 703.20 2018-09-26, SELL CREATE, 259.00 2018-09-27, SELL EXECUTED, Price: 259.00, Cost: 93760.00, Comm 621.60 2018-09-27, OPERATION PROFIT, GROSS -10880.00, NET -12204.80 2018-10-01, BUY CREATE, 252.00 2018-10-01, Cash: 82456.24399999999 2018-10-01, Price: 252.0 2018-10-01, Buy prop size: 324 2018-10-01, Afforded size: 324 2018-10-01, Final size: 324 2018-10-02, BUY EXECUTED, Price: 252.00, Cost: 81648.00, Comm 612.36 2018-10-10, SELL CREATE, 254.00 2018-10-11, SELL EXECUTED, Price: 254.00, Cost: 81648.00, Comm 617.22 2018-10-11, OPERATION PROFIT, GROSS 648.00, NET -581.58 2018-11-20, BUY CREATE, 279.00 2018-11-20, Cash: 81874.66399999999 2018-11-20, Price: 279.0 2018-11-20, Buy prop size: 290 2018-11-20, Afforded size: 290 2018-11-20, Final size: 290 2018-11-21, BUY EXECUTED, Price: 279.00, Cost: 80910.00, Comm 606.82 2018-12-19, SELL CREATE, 303.00 2018-12-20, SELL EXECUTED, Price: 303.00, Cost: 80910.00, Comm 659.02 Final PnL: -12431.19 Final PnL: -12431.19 ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== fast_period : 35 slow_period : 40 ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== rsi_period : 14 rsi_upper : 70 rsi_lower : 30 2018-06-01, BUY CREATE, 283.80 2018-06-01, Cash: 100000.0 2018-06-01, Price: 283.8 2018-06-01, Buy prop size: 349 2018-06-01, Afforded size: 349 2018-06-01, Final size: 349 2018-06-04, BUY EXECUTED, Price: 283.80, Cost: 99046.20, Comm 742.85 2018-06-04, SELL CREATE, 280.20 2018-06-05, SELL EXECUTED, Price: 280.20, Cost: 99046.20, Comm 733.42 2018-06-05, OPERATION PROFIT, GROSS -1256.40, NET -2732.67 2018-06-29, BUY CREATE, 263.00 2018-06-29, Cash: 97267.32999999999 2018-06-29, Price: 263.0 2018-06-29, Buy prop size: 366 2018-06-29, Afforded size: 366 2018-06-29, Final size: 366 2018-07-02, BUY EXECUTED, Price: 263.00, Cost: 96258.00, Comm 721.94 2018-07-03, SELL CREATE, 259.80 2018-07-04, SELL EXECUTED, Price: 259.80, Cost: 96258.00, Comm 713.15 2018-07-04, OPERATION PROFIT, GROSS -1171.20, NET -2606.29 2018-07-06, BUY CREATE, 251.00 2018-07-06, Cash: 94661.044 2018-07-06, Price: 251.0 2018-07-06, Buy prop size: 373 2018-07-06, Afforded size: 373 2018-07-06, Final size: 373 2018-07-09, BUY EXECUTED, Price: 251.00, Cost: 93623.00, Comm 702.17 2018-07-09, BUY CREATE, 245.00 2018-07-09, Cash: 335.8714999999944 2018-07-09, Price: 245.0 2018-07-09, Buy prop size: 1 2018-07-09, Afforded size: 1 2018-07-09, Final size: 1 2018-07-10, BUY EXECUTED, Price: 245.00, Cost: 245.00, Comm 1.84 2018-08-01, SELL CREATE, 276.00 2018-08-02, SELL EXECUTED, Price: 276.00, Cost: 93868.00, Comm 774.18 2018-08-02, OPERATION PROFIT, GROSS 9356.00, NET 7877.81 2018-08-23, BUY CREATE, 293.00 2018-08-23, Cash: 102538.854 2018-08-23, Price: 293.0 2018-08-23, Buy prop size: 347 2018-08-23, Afforded size: 347 2018-08-23, Final size: 347 2018-08-24, BUY EXECUTED, Price: 293.00, Cost: 101671.00, Comm 762.53 2018-09-26, SELL CREATE, 259.00 2018-09-27, SELL EXECUTED, Price: 259.00, Cost: 101671.00, Comm 674.05 2018-09-27, OPERATION PROFIT, GROSS -11798.00, NET -13234.58 2018-10-01, BUY CREATE, 252.00 2018-10-01, Cash: 89304.274 2018-10-01, Price: 252.0 2018-10-01, Buy prop size: 351 2018-10-01, Afforded size: 351 2018-10-01, Final size: 351 2018-10-02, BUY EXECUTED, Price: 252.00, Cost: 88452.00, Comm 663.39 2018-10-10, SELL CREATE, 254.00 2018-10-11, SELL EXECUTED, Price: 254.00, Cost: 88452.00, Comm 668.65 2018-10-11, OPERATION PROFIT, GROSS 702.00, NET -630.05 2018-11-20, BUY CREATE, 279.00 2018-11-20, Cash: 88674.229 2018-11-20, Price: 279.0 2018-11-20, Buy prop size: 315 2018-11-20, Afforded size: 315 2018-11-20, Final size: 315 2018-11-21, BUY EXECUTED, Price: 279.00, Cost: 87885.00, Comm 659.14 2018-12-19, SELL CREATE, 303.00 2018-12-20, SELL EXECUTED, Price: 303.00, Cost: 87885.00, Comm 715.84 Final PnL: -5140.75 Final PnL: -5140.75 ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== fast_period : 35 slow_period : 50 ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== rsi_period : 14 rsi_upper : 70 rsi_lower : 15 2018-08-29, BUY CREATE, 287.40 2018-08-29, Cash: 100000.0 2018-08-29, Price: 287.4 2018-08-29, Buy prop size: 345 2018-08-29, Afforded size: 345 2018-08-29, Final size: 345 2018-08-30, BUY EXECUTED, Price: 287.40, Cost: 99153.00, Comm 743.65 2018-10-08, SELL CREATE, 252.40 2018-10-09, SELL EXECUTED, Price: 252.40, Cost: 99153.00, Comm 653.09 2018-10-09, OPERATION PROFIT, GROSS -12075.00, NET -13471.73 2018-11-22, BUY CREATE, 285.00 2018-11-22, Cash: 86528.2675 2018-11-22, Price: 285.0 2018-11-22, Buy prop size: 301 2018-11-22, Afforded size: 301 2018-11-22, Final size: 301 2018-11-23, BUY EXECUTED, Price: 285.00, Cost: 85785.00, Comm 643.39 2018-12-19, SELL CREATE, 303.00 2018-12-20, SELL EXECUTED, Price: 303.00, Cost: 85785.00, Comm 684.02 Final PnL: -9381.14 Final PnL: -9381.14 ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== fast_period : 35 slow_period : 50 ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== rsi_period : 14 rsi_upper : 70 rsi_lower : 30 2018-07-06, BUY CREATE, 251.00 2018-07-06, Cash: 100000.0 2018-07-06, Price: 251.0 2018-07-06, Buy prop size: 395 2018-07-06, Afforded size: 395 2018-07-06, Final size: 395 2018-07-09, BUY EXECUTED, Price: 251.00, Cost: 99145.00, Comm 743.59 2018-08-01, SELL CREATE, 276.00 2018-08-02, SELL EXECUTED, Price: 276.00, Cost: 99145.00, Comm 817.65 2018-08-02, OPERATION PROFIT, GROSS 9875.00, NET 8313.76 2018-08-29, BUY CREATE, 287.40 2018-08-29, Cash: 108313.76250000001 2018-08-29, Price: 287.4 2018-08-29, Buy prop size: 373 2018-08-29, Afforded size: 373 2018-08-29, Final size: 373 2018-08-30, BUY EXECUTED, Price: 287.40, Cost: 107200.20, Comm 804.00 2018-10-08, SELL CREATE, 252.40 2018-10-08, BUY CREATE, 243.00 2018-10-08, Cash: 309.5610000000147 2018-10-08, Price: 243.0 2018-10-08, Buy prop size: 1 2018-10-08, Afforded size: 1 2018-10-08, Final size: 1 2018-10-09, SELL EXECUTED, Price: 252.40, Cost: 107200.20, Comm 706.09 2018-10-09, OPERATION PROFIT, GROSS -13055.00, NET -14565.09 2018-10-09, BUY EXECUTED, Price: 243.00, Cost: 243.00, Comm 1.82 2018-11-22, BUY CREATE, 285.00 2018-11-22, Cash: 93503.84950000003 2018-11-22, Price: 285.0 2018-11-22, Buy prop size: 325 2018-11-22, Afforded size: 325 2018-11-22, Final size: 325 2018-11-23, BUY EXECUTED, Price: 285.00, Cost: 92625.00, Comm 694.69 2018-12-19, SELL CREATE, 303.00 2018-12-20, SELL EXECUTED, Price: 303.00, Cost: 92868.00, Comm 740.83 Final PnL: -1778.67 Final PnL: -1778.67 ================================================== Number of strat runs: 4 Number of strats per run: 2 Strat names: [&#39;smac&#39;, &#39;rsi&#39;] ************************************************** -- {&#39;init_cash&#39;: 100000, &#39;buy_prop&#39;: 1, &#39;sell_prop&#39;: 1, &#39;execution_type&#39;: &#39;close&#39;, &#39;smac.fast_period&#39;: 35, &#39;smac.slow_period&#39;: 40, &#39;rsi.rsi_period&#39;: 14, &#39;rsi.rsi_upper&#39;: 70, &#39;rsi.rsi_lower&#39;: 15} OrderedDict([(&#39;rtot&#39;, -0.13274525599662523), (&#39;ravg&#39;, -0.0005462767736486635), (&#39;rnorm&#39;, -0.12860660663406134), (&#39;rnorm100&#39;, -12.860660663406135)]) OrderedDict([(&#39;sharperatio&#39;, None)]) ************************************************** -- {&#39;init_cash&#39;: 100000, &#39;buy_prop&#39;: 1, &#39;sell_prop&#39;: 1, &#39;execution_type&#39;: &#39;close&#39;, &#39;smac.fast_period&#39;: 35, &#39;smac.slow_period&#39;: 40, &#39;rsi.rsi_period&#39;: 14, &#39;rsi.rsi_upper&#39;: 70, &#39;rsi.rsi_lower&#39;: 30} OrderedDict([(&#39;rtot&#39;, -0.05277592979053591), (&#39;ravg&#39;, -0.0002171848962573494), (&#39;rnorm&#39;, -0.053259828782384624), (&#39;rnorm100&#39;, -5.325982878238462)]) OrderedDict([(&#39;sharperatio&#39;, None)]) ************************************************** -- {&#39;init_cash&#39;: 100000, &#39;buy_prop&#39;: 1, &#39;sell_prop&#39;: 1, &#39;execution_type&#39;: &#39;close&#39;, &#39;smac.fast_period&#39;: 35, &#39;smac.slow_period&#39;: 50, &#39;rsi.rsi_period&#39;: 14, &#39;rsi.rsi_upper&#39;: 70, &#39;rsi.rsi_lower&#39;: 15} OrderedDict([(&#39;rtot&#39;, -0.09850785442071867), (&#39;ravg&#39;, -0.00040538211695769004), (&#39;rnorm&#39;, -0.09711157492741003), (&#39;rnorm100&#39;, -9.711157492741004)]) OrderedDict([(&#39;sharperatio&#39;, None)]) ************************************************** -- {&#39;init_cash&#39;: 100000, &#39;buy_prop&#39;: 1, &#39;sell_prop&#39;: 1, &#39;execution_type&#39;: &#39;close&#39;, &#39;smac.fast_period&#39;: 35, &#39;smac.slow_period&#39;: 50, &#39;rsi.rsi_period&#39;: 14, &#39;rsi.rsi_upper&#39;: 70, &#39;rsi.rsi_lower&#39;: 30} OrderedDict([(&#39;rtot&#39;, -0.0179468149815959), (&#39;ravg&#39;, -7.385520568557983e-05), (&#39;rnorm&#39;, -0.018439387134145634), (&#39;rnorm100&#39;, -1.8439387134145633)]) OrderedDict([(&#39;sharperatio&#39;, None)]) Time used (seconds): 0.29656362533569336 Optimal parameters: {&#39;init_cash&#39;: 100000, &#39;buy_prop&#39;: 1, &#39;sell_prop&#39;: 1, &#39;execution_type&#39;: &#39;close&#39;, &#39;smac.fast_period&#39;: 35, &#39;smac.slow_period&#39;: 50, &#39;rsi.rsi_period&#39;: 14, &#39;rsi.rsi_upper&#39;: 70, &#39;rsi.rsi_lower&#39;: 30} Optimal metrics: {&#39;rtot&#39;: -0.0179468149815959, &#39;ravg&#39;: -7.385520568557983e-05, &#39;rnorm&#39;: -0.018439387134145634, &#39;rnorm100&#39;: -1.8439387134145633, &#39;sharperatio&#39;: None, &#39;pnl&#39;: -1778.67, &#39;final_value&#39;: 98221.32700000002} . (4, 16) . res_opt . init_cash buy_prop sell_prop execution_type smac.fast_period smac.slow_period rsi.rsi_period rsi.rsi_upper rsi.rsi_lower rtot ravg rnorm rnorm100 sharperatio pnl final_value . 0 100000 | 1 | 1 | close | 35 | 50 | 14 | 70 | 30 | -0.017947 | -0.000074 | -0.018439 | -1.843939 | None | -1778.67 | 98221.3270 | . 1 100000 | 1 | 1 | close | 35 | 40 | 14 | 70 | 30 | -0.052776 | -0.000217 | -0.053260 | -5.325983 | None | -5140.75 | 94859.2540 | . 2 100000 | 1 | 1 | close | 35 | 50 | 14 | 70 | 15 | -0.098508 | -0.000405 | -0.097112 | -9.711157 | None | -9381.14 | 90618.8575 | . 3 100000 | 1 | 1 | close | 35 | 40 | 14 | 70 | 15 | -0.132745 | -0.000546 | -0.128607 | -12.860661 | None | -12431.19 | 87568.8140 | .",
            "url": "https://enzoampil.github.io/fastquant-blog/2020/07/14/backtest-multi-strategy.html",
            "relUrl": "/2020/07/14/backtest-multi-strategy.html",
            "date": " • Jul 14, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "backtest crypto using fastquant",
            "content": ". # uncomment to install in colab # !pip install -e git+https://github.com/enzoampil/fastquant.git@master#egg=fastquant . fetch data from binance . from fastquant import get_crypto_data crypto = get_crypto_data(&quot;BTC/USDT&quot;, &quot;2018-12-01&quot;, &quot;2019-12-31&quot;) . crypto . open high low close volume . dt . 2018-12-01 4041.27 | 4299.99 | 3963.01 | 4190.02 | 44840.073481 | . 2018-12-02 4190.98 | 4312.99 | 4103.04 | 4161.01 | 38912.154790 | . 2018-12-03 4160.55 | 4179.00 | 3827.00 | 3884.01 | 49094.369163 | . 2018-12-04 3884.76 | 4085.00 | 3781.00 | 3951.64 | 48489.551613 | . 2018-12-05 3950.98 | 3970.00 | 3745.00 | 3769.84 | 44004.799448 | . ... ... | ... | ... | ... | ... | . 2019-12-27 7202.00 | 7275.86 | 7076.42 | 7254.74 | 33642.701861 | . 2019-12-28 7254.77 | 7365.01 | 7238.67 | 7316.14 | 26848.982199 | . 2019-12-29 7315.36 | 7528.45 | 7288.00 | 7388.24 | 31387.106085 | . 2019-12-30 7388.43 | 7408.24 | 7220.00 | 7246.00 | 29605.911782 | . 2019-12-31 7246.00 | 7320.00 | 7145.01 | 7195.23 | 25954.453533 | . 396 rows × 5 columns . import matplotlib as mpl mpl.style.use(&quot;default&quot;) . run backtest with a grid of values . from fastquant import backtest results = backtest(&#39;smac&#39;, crypto, fast_period=[7,14,21,28], slow_period=[30,45,60,75], plot=False, verbose=False ) . ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== fast_period : 7 slow_period : 30 Final PnL: 69071.42 ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== fast_period : 7 slow_period : 45 Final PnL: 100118.27 ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== fast_period : 7 slow_period : 60 Final PnL: 89293.45 ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== fast_period : 7 slow_period : 75 Final PnL: 158274.34 ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== fast_period : 14 slow_period : 30 Final PnL: 61540.07 ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== fast_period : 14 slow_period : 45 Final PnL: 66942.25 ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== fast_period : 14 slow_period : 60 Final PnL: 49672.26 ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== fast_period : 14 slow_period : 75 Final PnL: 129623.52 ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== fast_period : 21 slow_period : 30 Final PnL: 19672.89 ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== fast_period : 21 slow_period : 45 Final PnL: 62647.45 ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== fast_period : 21 slow_period : 60 Final PnL: 82714.92 ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== fast_period : 21 slow_period : 75 Final PnL: 118664.47 ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== fast_period : 28 slow_period : 30 Final PnL: 403.13 ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== fast_period : 28 slow_period : 45 Final PnL: 100206.68 ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== fast_period : 28 slow_period : 60 Final PnL: 153759.0 ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== fast_period : 28 slow_period : 75 Final PnL: 115821.6 Time used (seconds): 3.6864774227142334 Optimal parameters: {&#39;init_cash&#39;: 100000, &#39;buy_prop&#39;: 1, &#39;sell_prop&#39;: 1, &#39;execution_type&#39;: &#39;close&#39;, &#39;fast_period&#39;: 7, &#39;slow_period&#39;: 75} Optimal metrics: {&#39;rtot&#39;: 0.9488521619078212, &#39;ravg&#39;: 0.0023960913179490433, &#39;rnorm&#39;: 0.8290834824298609, &#39;rnorm100&#39;: 82.90834824298608, &#39;sharperatio&#39;: 0.9873637127933005, &#39;pnl&#39;: 158274.34, &#39;final_value&#39;: 258274.33860000005} . results.head() . init_cash buy_prop sell_prop execution_type fast_period slow_period rtot ravg rnorm rnorm100 sharperatio pnl final_value . 0 100000 | 1 | 1 | close | 7 | 75 | 0.948852 | 0.002396 | 0.829083 | 82.908348 | 0.987364 | 158274.34 | 258274.33860 | . 1 100000 | 1 | 1 | close | 28 | 60 | 0.931215 | 0.002352 | 0.808669 | 80.866904 | 0.986993 | 153759.00 | 253758.99660 | . 2 100000 | 1 | 1 | close | 14 | 75 | 0.831271 | 0.002099 | 0.697218 | 69.721824 | 0.984571 | 129623.52 | 229623.51945 | . 3 100000 | 1 | 1 | close | 21 | 75 | 0.782368 | 0.001976 | 0.645214 | 64.521440 | 0.983146 | 118664.47 | 218664.46810 | . 4 100000 | 1 | 1 | close | 28 | 75 | 0.769282 | 0.001943 | 0.631571 | 63.157054 | 0.982732 | 115821.60 | 215821.60410 | . That&#39;s a 258% maximum profit using only SMAC! . #get best parameters on top row fast_best, slow_best = results.iloc[0][[&quot;fast_period&quot;,&quot;slow_period&quot;]] fast_best, slow_best . (7, 75) . run backtest using optimum values . results = backtest(&#39;smac&#39;, crypto, fast_period=fast_best, slow_period=slow_best, plot=True, verbose=False ) . ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== fast_period : 7 slow_period : 75 Final PnL: 158274.34 Time used (seconds): 0.6577110290527344 Optimal parameters: {&#39;init_cash&#39;: 100000, &#39;buy_prop&#39;: 1, &#39;sell_prop&#39;: 1, &#39;execution_type&#39;: &#39;close&#39;, &#39;fast_period&#39;: 7, &#39;slow_period&#39;: 75} Optimal metrics: {&#39;rtot&#39;: 0.9488521619078212, &#39;ravg&#39;: 0.0023960913179490433, &#39;rnorm&#39;: 0.8290834824298609, &#39;rnorm100&#39;: 82.90834824298608, &#39;sharperatio&#39;: 0.9873637127933005, &#39;pnl&#39;: 158274.34, &#39;final_value&#39;: 258274.33860000005} .",
            "url": "https://enzoampil.github.io/fastquant-blog/2020/07/14/backtest-crypto.html",
            "relUrl": "/2020/07/14/backtest-crypto.html",
            "date": " • Jul 14, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Title",
            "content": ". # uncomment to install in colab # !pip install -e git+https://github.com/enzoampil/fastquant.git@master#egg=fastquant . Company disclosures-based trading strategy . from fastquant import DisclosuresPSE dpse = DisclosuresPSE(&quot;JFC&quot;, start_date=&quot;01-01-2015&quot;) . Pulling JFC disclosures summary... 3 pages detected! Found 145 disclosures between 01-01-2015 &amp; 07-15-2020 with 16 types: [&#39;Material Information/Transactions&#39; &#34;Notice of Annual or Special Stockholders&#39; Meeting&#34; &#39;Press Release&#39; &#34;Notice of Analysts&#39;/Investors&#39; Briefing&#34; &#39;Declaration of Cash Dividends&#39; &#39;Joint Ventures&#39; &#39;Change in Corporate Contact Details and/or Website&#39; &#39;Substantial Acquisitions&#39; &#39;Clarification of News Reports&#39; &#34;Results of Annual or Special Stockholders&#39; Meeting&#34; &#39;Results of Organizational Meeting of Board of Directors&#39; &#39;Acquisition or Disposition of Shares of Another Corporation&#39; &#39;Change in Directors and/or Officers (Resignation, Removal or Appointment, Election and/or Promotion)&#39; &#39;Amendments to By-Laws&#39; &#39;Amendments to Articles of Incorporation&#39; &#39;Update on Corporate Actions/Material Transactions/Agreements&#39;] Pulling details in all JFC disclosures... . 100%|██████████| 1/1 [00:00&lt;00:00, 6.50it/s] . Loaded: /home/jgendrinal/rprojects/fastquant/examples/src/fastquant/python/fastquant/data/JFC_disclosures_01-01-2015_07-15-2020.csv . dpse.disclosures_combined . Company Name Template Name PSE Form Number Announce Date and Time Circular Number edge_no url disclosure_table Background/Description of the Disclosure Subject of the Disclosure . 0 Jollibee Foods Corporation | [Amend-1]Material Information/Transactions | 4-30 | 2020-06-25 07:37:00 | C04444-2020 | 68f4aa3616d6457c0de8473cebbd6407 | https://edge.pse.com.ph/openDiscViewer.do?edge... | {&quot;Title of Each Class&quot;: &quot;Common&quot;, &quot;Subject of ... | Jollibee Foods Corporation (JFC, the “Guaranto... | JFC to Issue US$ 600 Million 5.5 and 10 Year N... | . 1 Jollibee Foods Corporation | Material Information/Transactions | 4-30 | 2020-06-19 08:01:00 | C04295-2020 | 0be4ceaf09ea28090de8473cebbd6407 | https://edge.pse.com.ph/openDiscViewer.do?edge... | {&quot;Title of Each Class&quot;: &quot;COMMON&quot;, &quot;Subject of ... | Golden Plate Pte. Ltd. (GPPL), a wholly owned ... | Jollibee Foods Corporation (JFC) and Dim Sum P... | . 2 Jollibee Foods Corporation | Material Information/Transactions | 4-30 | 2020-06-17 10:39:00 | C04227-2020 | d1a0237ac4559bda0de8473cebbd6407 | https://edge.pse.com.ph/openDiscViewer.do?edge... | {&quot;Title of Each Class&quot;: &quot;COMMON&quot;, &quot;Subject of ... | Jollibee Foods Corporation (JFC) announced tha... | Cash dividend declaration | . 3 Jollibee Foods Corporation | Notice of Annual or Special Stockholders&#39; Meeting | 7-1 | 2020-05-28 07:23:00 | C03757-2020 | 3d7278efdfc3720b0de8473cebbd6407 | https://edge.pse.com.ph/openDiscViewer.do?edge... | {&quot;Title of Each Class&quot;: &quot;COMMON&quot;, &quot;Subject of ... | In compliance with National Telecommunication ... | Update of Corporate Contact Details | . 4 Jollibee Foods Corporation | Press Release | 4-31 | 2020-05-28 07:17:00 | C03749-2020 | 55ee488e963620db0de8473cebbd6407 | https://edge.pse.com.ph/openDiscViewer.do?edge... | {&quot;Title of Each Class&quot;: &quot;COMMON&quot;, &quot;Subject of ... | Further to its May 8, 2018 disclosure, JFC dis... | JFC to increase investment in Buyer of Tim Ho ... | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 140 Jollibee Foods Corporation | Declaration of Cash Dividends | 6-1 | 2015-04-08 08:39:00 | C01729-2015 | 49a8d6ba7f7608fcb15effbf9088d1ab | https://edge.pse.com.ph/openDiscViewer.do?edge... | {&quot;Title of Each Class&quot;: &quot;Common&quot;, &quot;Subject of ... | Jollibee Worldwide Pte. Ltd., (the “Issuer”), ... | JFC Mandates Banks for U.S.$ Senior Unsecured ... | . 141 Jollibee Foods Corporation | Press Release | 4-31 | 2015-02-23 13:41:00 | C00789-2015 | 929338ec12042f71b15effbf9088d1ab | https://edge.pse.com.ph/openDiscViewer.do?edge... | {&quot;Title of Each Class&quot;: &quot;COMMON&quot;, &quot;Subject of ... | Notice of annual stockholders&#39; meeting for the... | Notice of annual stockholders&#39; meeting for the... | . 142 Jollibee Foods Corporation | Clarification of News Reports | 4-13 | 2015-01-22 14:28:00 | C00256-2015 | 7578082745af0a94b15effbf9088d1ab | https://edge.pse.com.ph/openDiscViewer.do?edge... | {&quot;Title of Each Class&quot;: &quot;Common&quot;, &quot;Subject of ... | JFC Announces First Quarter 2020 Financial Res... | Press Release: 2020 1st Quarter Financial Results | . 143 Jollibee Foods Corporation | Update on Corporate Actions/Material Transacti... | 16-1 | 2015-01-09 13:24:00 | C00092-2015 | 09cd76ec59b47b6db15effbf9088d1ab | https://edge.pse.com.ph/openDiscViewer.do?edge... | {&quot;Title of Each Class&quot;: &quot;Common&quot;, &quot;Subject of ... | Jollibee Foods Corporation, one of Asia&#39;s larg... | JFC to Spend Php7 Billion for Business Transfo... | . 144 Jollibee Foods Corporation | Update on Corporate Actions/Material Transacti... | 16-1 | 2015-01-06 07:51:00 | C00024-2015 | 56a1e05383b8fec9b15effbf9088d1ab | https://edge.pse.com.ph/openDiscViewer.do?edge... | {&quot;Title of Each Class&quot;: &quot;common &quot;, &quot;Subject of... | Jollibee Foods Corporation will do an Earnings... | JFC’s Earnings Call for its First Quarter 2020... | . 145 rows × 10 columns . #!pip install nltk . import nltk import warnings warnings.filterwarnings(&#39;ignore&#39;) from nltk.sentiment.vader import SentimentIntensityAnalyzer nltk.download(&#39;vader_lexicon&#39;) sia = SentimentIntensityAnalyzer() . [nltk_data] Downloading package vader_lexicon to [nltk_data] /home/jgendrinal/nltk_data... [nltk_data] Package vader_lexicon is already up-to-date! . # nltk.download(&#39;punkt&#39;) # nltk.download(&#39;averaged_perceptron_tagger&#39;) . date_sentiments = {} for idx,row in dpse.disclosures_combined.iterrows(): date = row[&#39;Announce Date and Time&#39;] paragraph = row[&#39;Background/Description of the Disclosure&#39;] if paragraph is not None: #split paragraph into sentences # sentences = nltk.sent_tokenize(paragraph) # for sentence in sentences: # sentiment = sia.polarity_scores(sentence)[&#39;compound&#39;] sentiment = sia.polarity_scores(paragraph)[&#39;compound&#39;] date_sentiments[date] = sentiment . date_sentiments . {Timestamp(&#39;2020-06-25 07:37:00&#39;): 0.9538, Timestamp(&#39;2020-06-19 08:01:00&#39;): 0.8176, Timestamp(&#39;2020-06-17 10:39:00&#39;): 0.8658, Timestamp(&#39;2020-05-28 07:23:00&#39;): 0.6908, Timestamp(&#39;2020-05-28 07:17:00&#39;): 0.936, Timestamp(&#39;2020-05-22 11:03:00&#39;): 0.7096, Timestamp(&#39;2020-04-15 07:41:00&#39;): 0.9796, Timestamp(&#39;2020-04-07 10:16:00&#39;): 0.8807, Timestamp(&#39;2020-03-20 07:16:00&#39;): 0.8074, Timestamp(&#39;2020-03-16 12:49:00&#39;): 0.4939, Timestamp(&#39;2020-03-13 15:49:00&#39;): 0.0, Timestamp(&#39;2020-02-18 15:26:00&#39;): 0.0, Timestamp(&#39;2020-02-04 09:34:00&#39;): 0.0, Timestamp(&#39;2020-01-24 07:35:00&#39;): 0.0, Timestamp(&#39;2020-01-17 08:17:00&#39;): 0.4019, Timestamp(&#39;2020-01-09 14:03:00&#39;): 0.4767, Timestamp(&#39;2019-11-14 11:38:00&#39;): 0.0, Timestamp(&#39;2019-11-14 08:06:00&#39;): 0.4767, Timestamp(&#39;2019-11-11 14:52:00&#39;): 0.91, Timestamp(&#39;2019-10-07 12:42:00&#39;): 0.0, Timestamp(&#39;2019-10-02 15:46:00&#39;): 0.7351, Timestamp(&#39;2019-09-24 15:43:00&#39;): 0.4767, Timestamp(&#39;2019-09-16 11:10:00&#39;): 0.0, Timestamp(&#39;2019-09-06 15:50:00&#39;): 0.7964, Timestamp(&#39;2019-09-06 15:17:00&#39;): 0.4215, Timestamp(&#39;2019-08-05 15:01:00&#39;): 0.6588, Timestamp(&#39;2019-08-01 09:48:00&#39;): 0.7351, Timestamp(&#39;2019-07-08 07:32:00&#39;): 0.4404, Timestamp(&#39;2019-07-01 13:15:00&#39;): 0.8176, Timestamp(&#39;2019-06-28 15:59:00&#39;): 0.0, Timestamp(&#39;2019-06-28 15:14:00&#39;): 0.0, Timestamp(&#39;2019-06-28 15:11:00&#39;): 0.0, Timestamp(&#39;2019-06-28 07:41:00&#39;): 0.4215, Timestamp(&#39;2019-05-29 11:41:00&#39;): 0.8316, Timestamp(&#39;2019-05-15 14:32:00&#39;): 0.0, Timestamp(&#39;2019-04-22 12:36:00&#39;): 0.0, Timestamp(&#39;2019-04-11 07:58:00&#39;): 0.0, Timestamp(&#39;2019-04-08 14:08:00&#39;): 0.0, Timestamp(&#39;2019-04-08 13:58:00&#39;): 0.0, Timestamp(&#39;2019-02-14 15:00:00&#39;): 0.0, Timestamp(&#39;2019-02-14 14:47:00&#39;): 0.4767, Timestamp(&#39;2018-12-21 13:37:00&#39;): 0.4404, Timestamp(&#39;2018-12-14 10:51:00&#39;): 0.4767, Timestamp(&#39;2018-12-03 08:28:00&#39;): 0.9953, Timestamp(&#39;2018-11-19 11:55:00&#39;): 0.6124, Timestamp(&#39;2018-11-12 13:07:00&#39;): 0.9862, Timestamp(&#39;2018-11-09 14:45:00&#39;): 0.8221, Timestamp(&#39;2018-10-15 13:58:00&#39;): 0.4404, Timestamp(&#39;2018-10-15 13:52:00&#39;): 0.7351, Timestamp(&#39;2018-09-07 08:34:00&#39;): 0.9459, Timestamp(&#39;2018-08-14 07:59:00&#39;): 0.0, Timestamp(&#39;2018-07-05 11:41:00&#39;): 0.4404, Timestamp(&#39;2018-07-05 11:35:00&#39;): 0.8977, Timestamp(&#39;2018-07-02 07:45:00&#39;): 0.4767, Timestamp(&#39;2018-06-29 15:43:00&#39;): 0.6705, Timestamp(&#39;2018-06-29 15:42:00&#39;): 0.8176, Timestamp(&#39;2018-06-29 15:41:00&#39;): 0.4767, Timestamp(&#39;2018-05-09 15:31:00&#39;): 0.0, Timestamp(&#39;2018-05-09 15:11:00&#39;): 0.7783, Timestamp(&#39;2018-04-17 10:01:00&#39;): 0.0, Timestamp(&#39;2018-04-17 08:38:00&#39;): 0.0, Timestamp(&#39;2018-04-11 13:54:00&#39;): 0.4404, Timestamp(&#39;2018-04-06 14:38:00&#39;): 0.9774, Timestamp(&#39;2018-04-05 08:04:00&#39;): 0.0, Timestamp(&#39;2018-03-08 10:23:00&#39;): 0.7351, Timestamp(&#39;2018-02-14 08:14:00&#39;): 0.4767, Timestamp(&#39;2018-02-13 15:18:00&#39;): 0.0, Timestamp(&#39;2018-02-13 14:29:00&#39;): 0.0, Timestamp(&#39;2017-12-26 11:09:00&#39;): 0.9627, Timestamp(&#39;2017-12-05 12:47:00&#39;): 0.0, Timestamp(&#39;2017-11-10 15:00:00&#39;): 0.4404, Timestamp(&#39;2017-11-10 14:36:00&#39;): 0.9747, Timestamp(&#39;2017-11-02 14:02:00&#39;): 0.985, Timestamp(&#39;2017-10-09 13:30:00&#39;): 0.5106, Timestamp(&#39;2017-09-19 12:31:00&#39;): 0.0, Timestamp(&#39;2017-08-14 11:49:00&#39;): 0.9971, Timestamp(&#39;2017-07-05 13:52:00&#39;): 0.4939, Timestamp(&#39;2017-07-03 14:14:00&#39;): 0.0, Timestamp(&#39;2017-06-30 15:21:00&#39;): 0.8176, Timestamp(&#39;2017-05-12 15:49:00&#39;): 0.0, Timestamp(&#39;2017-05-11 15:46:00&#39;): 0.0, Timestamp(&#39;2017-04-06 07:52:00&#39;): 0.0, Timestamp(&#39;2017-04-05 14:56:00&#39;): 0.4939, Timestamp(&#39;2017-04-03 08:37:00&#39;): 0.4939, Timestamp(&#39;2017-03-29 12:04:00&#39;): 0.3182, Timestamp(&#39;2017-03-14 14:45:00&#39;): 0.4767, Timestamp(&#39;2017-02-16 07:39:00&#39;): 0.296, Timestamp(&#39;2017-02-14 14:47:00&#39;): 0.0, Timestamp(&#39;2017-01-03 07:38:00&#39;): 0.836, Timestamp(&#39;2016-12-23 12:56:00&#39;): 0.9882, Timestamp(&#39;2016-12-15 09:16:00&#39;): 0.0, Timestamp(&#39;2016-12-13 08:12:00&#39;): 0.4404, Timestamp(&#39;2016-11-23 12:13:00&#39;): 0.807, Timestamp(&#39;2016-11-21 07:58:00&#39;): 0.807, Timestamp(&#39;2016-11-17 07:44:00&#39;): 0.4019, Timestamp(&#39;2016-11-15 09:19:00&#39;): 0.6705, Timestamp(&#39;2016-11-11 14:49:00&#39;): 0.8176, Timestamp(&#39;2016-08-09 12:22:00&#39;): 0.8016, Timestamp(&#39;2016-07-22 16:04:00&#39;): 0.8478, Timestamp(&#39;2016-07-22 16:03:00&#39;): 0.7003, Timestamp(&#39;2016-05-25 08:28:00&#39;): 0.0, Timestamp(&#39;2016-05-25 08:19:00&#39;): 0.4939, Timestamp(&#39;2016-05-13 12:06:00&#39;): 0.4404, Timestamp(&#39;2016-05-12 14:42:00&#39;): 0.0, Timestamp(&#39;2016-04-22 11:18:00&#39;): 0.0, Timestamp(&#39;2016-04-11 11:49:00&#39;): 0.4767, Timestamp(&#39;2016-04-06 15:20:00&#39;): 0.3182, Timestamp(&#39;2016-02-24 08:34:00&#39;): 0.4404, Timestamp(&#39;2016-02-15 11:53:00&#39;): 0.6124, Timestamp(&#39;2016-02-09 15:24:00&#39;): 0.5423, Timestamp(&#39;2016-01-14 08:26:00&#39;): 0.6597, Timestamp(&#39;2015-11-23 15:27:00&#39;): 0.8176, Timestamp(&#39;2015-11-09 14:43:00&#39;): 0.0, Timestamp(&#39;2015-11-09 14:42:00&#39;): 0.7845, Timestamp(&#39;2015-11-02 10:12:00&#39;): 0.9838, Timestamp(&#39;2015-10-27 08:22:00&#39;): 0.9334, Timestamp(&#39;2015-10-13 08:31:00&#39;): 0.4215, Timestamp(&#39;2015-10-02 13:49:00&#39;): 0.8176, Timestamp(&#39;2015-09-18 09:47:00&#39;): 0.0, Timestamp(&#39;2015-08-26 09:16:00&#39;): 0.9081, Timestamp(&#39;2015-08-07 13:31:00&#39;): 0.3182, Timestamp(&#39;2015-06-29 08:10:00&#39;): 0.9792, Timestamp(&#39;2015-06-26 16:03:00&#39;): 0.9792, Timestamp(&#39;2015-05-14 08:30:00&#39;): 0.802, Timestamp(&#39;2015-05-13 14:57:00&#39;): 0.9538, Timestamp(&#39;2015-04-08 08:41:00&#39;): 0.9538, Timestamp(&#39;2015-04-08 08:39:00&#39;): 0.7184, Timestamp(&#39;2015-02-23 13:41:00&#39;): 0.4767, Timestamp(&#39;2015-01-22 14:28:00&#39;): -0.3182, Timestamp(&#39;2015-01-09 13:24:00&#39;): 0.8625, Timestamp(&#39;2015-01-06 07:51:00&#39;): 0.6124} . from __future__ import (absolute_import, division, print_function, unicode_literals) import matplotlib.pyplot as pl pl.style.use(&quot;default&quot;) import backtrader as bt import backtrader.indicators as btind from datetime import datetime import os.path import sys class Sentiment(bt.Indicator): lines = (&#39;sentiment&#39;,) plotinfo = dict( plotymargin=0.15, plothlines=[0], plotyticks=[1.0, 0, -1.0]) def next(self): self.date = self.data.datetime date = bt.num2date(self.date[0]).date() prev_sentiment = self.sentiment if date in date_sentiments: self.sentiment = date_sentiments[date] self.lines.sentiment[0] = self.sentiment class SentimentStrat(bt.Strategy): params = ( (&#39;period&#39;, 15), (&#39;printlog&#39;, True), ) def log(self, txt, dt=None, doprint=False): &#39;&#39;&#39; Logging function for this strategy&#39;&#39;&#39; if self.params.printlog or doprint: dt = dt or self.datas[0].datetime.date(0) print(&#39;%s, %s&#39; % (dt.isoformat(), txt)) def __init__(self): # Keep a reference to the &quot;close&quot; line in the data[0] dataseries self.dataclose = self.datas[0].close # Keep track of pending orders self.order = None self.buyprice = None self.buycomm = None self.sma = bt.indicators.SimpleMovingAverage( self.datas[0], period=self.params.period) self.date = self.data.datetime self.sentiment = None Sentiment(self.data) def notify_order(self, order): if order.status in [order.Submitted, order.Accepted]: # Buy/Sell order submitted/accepted to/by broker - Nothing to do return # Check if an order has been completed # Attention: broker could reject order if not enough cash if order.status in [order.Completed]: if order.isbuy(): self.log( &#39;BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f&#39; % (order.executed.price, order.executed.value, order.executed.comm)) self.buyprice = order.executed.price self.buycomm = order.executed.comm else: # Sell self.log(&#39;SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f&#39; % (order.executed.price, order.executed.value, order.executed.comm)) self.bar_executed = len(self) elif order.status in [order.Canceled, order.Margin, order.Rejected]: self.log(&#39;Order Canceled/Margin/Rejected&#39;) # Write down: no pending order self.order = None def notify_trade(self, trade): if not trade.isclosed: return self.log(&#39;OPERATION PROFIT, GROSS %.2f, NET %.2f&#39; % (trade.pnl, trade.pnlcomm)) ### Main Strat ### def next(self): # log closing price of the series from the reference self.log(&#39;Close, %.2f&#39; % self.dataclose[0]) date = bt.num2date(self.date[0]).date() prev_sentiment = self.sentiment if date in date_sentiments: self.sentiment = date_sentiments[date] # Check if an order is pending. if yes, we cannot send a 2nd one if self.order: return print(self.sentiment) # If not in the market and previous sentiment not none if not self.position and prev_sentiment: # buy if current close more than sma AND sentiment increased by &gt;= 0.5 if self.dataclose[0] &gt; self.sma[0] and self.sentiment - prev_sentiment &gt;= 0.5: self.log(&#39;BUY CREATE, %.2f&#39; % self.dataclose[0]) self.order = self.buy() # Already in the market and previous sentiment not none elif prev_sentiment: # sell if current close less than sma AND sentiment decreased by &gt;= 0.5 if self.dataclose[0] &lt; self.sma[0] and self.sentiment - prev_sentiment &lt;= -0.5: self.log(&#39;SELL CREATE, %.2f&#39; % self.dataclose[0]) self.order = self.sell() def stop(self): self.log(&#39;(MA Period %2d) Ending Value %.2f&#39; % (self.params.period, self.broker.getvalue()), doprint=True) if __name__ == &#39;__main__&#39;: cerebro = bt.Cerebro() # Strategy cerebro.addstrategy(SentimentStrat) # Data Feed data = bt.feeds.YahooFinanceData( dataname = &#39;JBFCF&#39;, fromdate = min(date_sentiments.keys()), todate = datetime.now().date(), reverse = False ) cerebro.adddata(data) cerebro.broker.setcash(100000.0) cerebro.addsizer(bt.sizers.FixedSize, stake=10) cerebro.broker.setcommission(commission=0.001) print(&#39;Starting Portfolio Value: %.2f&#39; % cerebro.broker.getvalue()) cerebro.run() print(&#39;Final Portfolio Value: %.2f&#39; % cerebro.broker.getvalue()) cerebro.plot() . Starting Portfolio Value: 100000.00 . TypeError Traceback (most recent call last) &lt;ipython-input-9-a24ff364b1c0&gt; in &lt;module&gt; 141 cerebro.broker.setcommission(commission=0.001) 142 print(&#39;Starting Portfolio Value: %.2f&#39; % cerebro.broker.getvalue()) --&gt; 143 cerebro.run() 144 print(&#39;Final Portfolio Value: %.2f&#39; % cerebro.broker.getvalue()) 145 ~/.local/lib/python3.8/site-packages/backtrader/cerebro.py in run(self, **kwargs) 1125 # let&#39;s skip process &#34;spawning&#34; 1126 for iterstrat in iterstrats: -&gt; 1127 runstrat = self.runstrategies(iterstrat) 1128 self.runstrats.append(runstrat) 1129 if self._dooptimize: ~/.local/lib/python3.8/site-packages/backtrader/cerebro.py in runstrategies(self, iterstrat, predata) 1291 self._runonce_old(runstrats) 1292 else: -&gt; 1293 self._runonce(runstrats) 1294 else: 1295 if self.p.oldsync: ~/.local/lib/python3.8/site-packages/backtrader/cerebro.py in _runonce(self, runstrats) 1650 &#39;&#39;&#39; 1651 for strat in runstrats: -&gt; 1652 strat._once() 1653 strat.reset() # strat called next by next - reset lines 1654 ~/.local/lib/python3.8/site-packages/backtrader/lineiterator.py in _once(self) 295 296 for indicator in self._lineiterators[LineIterator.IndType]: --&gt; 297 indicator._once() 298 299 for observer in self._lineiterators[LineIterator.ObsType]: ~/.local/lib/python3.8/site-packages/backtrader/lineiterator.py in _once(self) 315 # indicators are each called with its min period 316 self.preonce(0, self._minperiod - 1) --&gt; 317 self.oncestart(self._minperiod - 1, self._minperiod) 318 self.once(self._minperiod, self.buflen()) 319 ~/.local/lib/python3.8/site-packages/backtrader/indicator.py in oncestart_via_nextstart(self, start, end) 122 123 self.advance() --&gt; 124 self.nextstart() 125 126 def once_via_next(self, start, end): ~/.local/lib/python3.8/site-packages/backtrader/lineiterator.py in nextstart(self) 345 346 # Called once for 1st full calculation - defaults to regular next --&gt; 347 self.next() 348 349 def next(self): &lt;ipython-input-9-a24ff364b1c0&gt; in next(self) 23 if date in date_sentiments: 24 self.sentiment = date_sentiments[date] &gt; 25 self.lines.sentiment[0] = self.sentiment 26 27 ~/.local/lib/python3.8/site-packages/backtrader/linebuffer.py in __setitem__(self, ago, value) 220 value (variable): value to be set 221 &#39;&#39;&#39; --&gt; 222 self.array[self.idx + ago] = value 223 for binding in self.bindings: 224 binding[ago] = value TypeError: must be real number, not LineBuffer . rappler news sentiment . from urllib.request import urlopen from bs4 import BeautifulSoup from datetime import datetime import time import nltk import warnings warnings.filterwarnings(&#39;ignore&#39;) from nltk.sentiment.vader import SentimentIntensityAnalyzer # nltk.download(&#39;vader_lexicon&#39;) sia = SentimentIntensityAnalyzer() base_url = &quot;http://rappler.com&quot; page = urlopen(base_url+&#39;/previous-articles?filterMeta=Jollibee&#39;).read() soup = BeautifulSoup(page, features=&quot;html.parser&quot;) posts = soup.findAll(&quot;div&quot;, {&quot;class&quot;: &quot;col-xs-12 col-sm-8&quot;}) date_sentiments = {} for post in posts[:10]: #default up to 50 posts time.sleep(1) url = post.a[&#39;href&#39;] #date = post.time.text date_string = post.span.text.split(&#39;-&#39;)[0].strip() date = datetime.strptime(date_string, &#39;%b %d, %Y&#39;).date() print(date, base_url+url) try: link_page = urlopen(base_url+url).read() except: url = url[:-2] link_page = urlopen(url).read() link_soup = BeautifulSoup(link_page) sentences = link_soup.findAll(&quot;p&quot;) passage = &quot;&quot; for sentence in sentences: passage += sentence.text sentiment = sia.polarity_scores(passage)[&#39;compound&#39;] date_sentiments[date] = sentiment . date_sentiments . from __future__ import (absolute_import, division, print_function, unicode_literals) import matplotlib.pyplot as pl pl.style.use(&quot;default&quot;) import backtrader as bt import backtrader.indicators as btind from datetime import datetime import os.path import sys class Sentiment(bt.Indicator): lines = (&#39;sentiment&#39;,) plotinfo = dict( plotymargin=0.15, plothlines=[0], plotyticks=[1.0, 0, -1.0]) def next(self): self.date = self.data.datetime date = bt.num2date(self.date[0]).date() prev_sentiment = self.sentiment if date in date_sentiments: print(date_sentiments[date]) self.sentiment = date_sentiments[date] self.lines.sentiment[0] = self.sentiment class SentimentStrat(bt.Strategy): params = ( (&#39;period&#39;, 15), (&#39;printlog&#39;, True), ) def log(self, txt, dt=None, doprint=False): &#39;&#39;&#39; Logging function for this strategy&#39;&#39;&#39; if self.params.printlog or doprint: dt = dt or self.datas[0].datetime.date(0) print(&#39;%s, %s&#39; % (dt.isoformat(), txt)) def __init__(self): # Keep a reference to the &quot;close&quot; line in the data[0] dataseries self.dataclose = self.datas[0].close # Keep track of pending orders self.order = None self.buyprice = None self.buycomm = None self.sma = bt.indicators.SimpleMovingAverage( self.datas[0], period=self.params.period) self.date = self.data.datetime self.sentiment = None Sentiment(self.data) def notify_order(self, order): if order.status in [order.Submitted, order.Accepted]: # Buy/Sell order submitted/accepted to/by broker - Nothing to do return # Check if an order has been completed # Attention: broker could reject order if not enough cash if order.status in [order.Completed]: if order.isbuy(): self.log( &#39;BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f&#39; % (order.executed.price, order.executed.value, order.executed.comm)) self.buyprice = order.executed.price self.buycomm = order.executed.comm else: # Sell self.log(&#39;SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f&#39; % (order.executed.price, order.executed.value, order.executed.comm)) self.bar_executed = len(self) elif order.status in [order.Canceled, order.Margin, order.Rejected]: self.log(&#39;Order Canceled/Margin/Rejected&#39;) # Write down: no pending order self.order = None def notify_trade(self, trade): if not trade.isclosed: return self.log(&#39;OPERATION PROFIT, GROSS %.2f, NET %.2f&#39; % (trade.pnl, trade.pnlcomm)) ### Main Strat ### def next(self): # log closing price of the series from the reference self.log(&#39;Close, %.2f&#39; % self.dataclose[0]) date = bt.num2date(self.date[0]).date() prev_sentiment = self.sentiment if date in date_sentiments: self.sentiment = date_sentiments[date] # Check if an order is pending. if yes, we cannot send a 2nd one if self.order: return print(self.sentiment) # If not in the market and previous sentiment not none if not self.position and prev_sentiment: # buy if current close more than sma AND sentiment increased by &gt;= 0.5 if self.dataclose[0] &gt; self.sma[0] and self.sentiment - prev_sentiment &gt;= 0.5: self.log(&#39;BUY CREATE, %.2f&#39; % self.dataclose[0]) self.order = self.buy() # Already in the market and previous sentiment not none elif prev_sentiment: # sell if current close less than sma AND sentiment decreased by &gt;= 0.5 if self.dataclose[0] &lt; self.sma[0] and self.sentiment - prev_sentiment &lt;= -0.5: self.log(&#39;SELL CREATE, %.2f&#39; % self.dataclose[0]) self.order = self.sell() def stop(self): self.log(&#39;(MA Period %2d) Ending Value %.2f&#39; % (self.params.period, self.broker.getvalue()), doprint=True) if __name__ == &#39;__main__&#39;: cerebro = bt.Cerebro() # Strategy cerebro.addstrategy(SentimentStrat) # Data Feed data = bt.feeds.YahooFinanceData( dataname = &#39;JBFCF&#39;, fromdate = min(date_sentiments.keys()), todate = datetime.now().date(), reverse = False ) cerebro.adddata(data) cerebro.broker.setcash(100000.0) cerebro.addsizer(bt.sizers.FixedSize, stake=10) cerebro.broker.setcommission(commission=0.001) print(&#39;Starting Portfolio Value: %.2f&#39; % cerebro.broker.getvalue()) cerebro.run() print(&#39;Final Portfolio Value: %.2f&#39; % cerebro.broker.getvalue()) cerebro.plot() .",
            "url": "https://enzoampil.github.io/fastquant-blog/2020/06/13/backtest_disclosures.html",
            "relUrl": "/2020/06/13/backtest_disclosures.html",
            "date": " • Jun 13, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "Some Basic Ideas",
            "content": ". # uncomment to install in colab # !pip install -e git+https://github.com/enzoampil/fastquant.git@master#egg=fastquant . Modern Portfolio Theory (Markowitz Model) . As mentioned above, investing in the stock market can result in either profit or loss. . In a nutshell, Modern Portfolio Theory is a way of maximizing return for a given risk. We will define what return and risk means shortly. . Let&#39;s understand this by using an example. . Suppose you wanted to invest in the stock market. After completing your research, you decided to invest in the following companies: . MEG | MAXS | JFC | ALI | . We will download the data for this using a python library called fastquant. It was actually developed by a fellow Filipino Data Scientist. It aims to democratize data-driven investments for everyone. . NOTE The model we&#39;ll be using relies on the assumption that returns are normally distributed. Therefore, it helps if we have large number of data points. . import pandas as pd import numpy as np import matplotlib.pyplot as plt import warnings import scipy.optimize as optimization from fastquant import get_stock_data warnings.filterwarnings(&#39;ignore&#39;) %matplotlib inline . stocks = [&#39;MEG&#39;, &#39;MAXS&#39;, &#39;JFC&#39;, &#39;ALI&#39;] datas = [] for i in stocks: df = get_stock_data(i, &quot;2017-01-01&quot;, &quot;2020-01-01&quot;) df.columns = [&#39;DATE&#39;,i,&#39;Volume&#39;] df = df[[&#39;DATE&#39;,i]] datas.append(df) datas1 = pd.merge(datas[0],datas[1],on=[&#39;DATE&#39;]) datas2 = pd.merge(datas[2],datas[3],on=[&#39;DATE&#39;]) # datas3 = pd.merge(datas[4],datas[5],on=[&#39;DATE&#39;]) # datas4 = pd.merge(datas1,datas2,on=[&#39;DATE&#39;]) data = pd.merge(datas1,datas2,on=[&#39;DATE&#39;]) data.index = data[&#39;DATE&#39;] data.drop(&#39;DATE&#39;,axis=1,inplace=True) . Reading cached file found: MEG_2017-01-01_2020-01-01.csv Reading cached file found: MAXS_2017-01-01_2020-01-01.csv Reading cached file found: JFC_2017-01-01_2020-01-01.csv Reading cached file found: ALI_2017-01-01_2020-01-01.csv . The table below shows the first 5 entries in our dataset. The values here are closing prices. A closing price is a price of a stock at the end of a given trading day. . data.head() . MEG MAXS JFC ALI . DATE . 2017-01-03 3.54 | 25.5 | 200.0 | 32.00 | . 2017-01-04 3.67 | 26.7 | 206.0 | 33.30 | . 2017-01-05 3.72 | 27.3 | 214.0 | 34.15 | . 2017-01-06 3.75 | 28.0 | 213.0 | 34.50 | . 2017-01-09 3.75 | 27.6 | 215.0 | 33.95 | . Now, let&#39;s ask ourselves. Why don&#39;t we invest in a single company, instead of investing in multiple companies? . Modern Portfolio Theory tells us that we can minimize our loss thru diversification. Let&#39;s understand this with an example. . Suppose you decided to invest on January 2017. For illustraton purposes, let&#39;s consider the period January 2017 - May 2018. . Case 1: You invested solely on MAXS | Case 2: You decided to invest 50% to MAXS and the other 50% to JFC | . If you decided to go with case 1, it would be clear that you could immediately lose some money (as the chart shows a decreasing trend). If you instead decided to go with Case 2, your loss could have been mitigated since the price for JFC is increasing during that period. . Of course you could argue that &quot;why not invest all of my money in JFC&quot;, well my counter argument to that would be, when JFC is experiencing a decline in it&#39;s price, there would be some other company that&#39;s actually experiencing an increase in it&#39;s price. . Key Takeaway . Invest in multiple stocks as much as possible, to minimize your loss. (Technically uncorrelated or negatively correlated) | . data[&#39;MAXS&#39;].plot(figsize=(12,5),legend=True) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f241afffe48&gt; . data[&#39;JFC&#39;].plot(figsize=(12,5),legend=True,color=&#39;r&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f2418eb37f0&gt; . Now, let&#39;s define what a return is. Intuitively, we can define return as : . The stock price today minus the stock price yesterday. Divide the difference by the stock price yesterday . More formally, . The return $R_{t,t+1}$ from time $t$ to time ${t+1}$ is given by: . $$ R_{t,t+1} = frac{P_{t+1}-P_{t}}{P_{t}} $$ . where $P_i$ is the price of the stock for a given time point. . returns = data.pct_change() returns . MEG MAXS JFC ALI . DATE . 2017-01-03 NaN | NaN | NaN | NaN | . 2017-01-04 0.036723 | 0.047059 | 0.030000 | 0.040625 | . 2017-01-05 0.013624 | 0.022472 | 0.038835 | 0.025526 | . 2017-01-06 0.008065 | 0.025641 | -0.004673 | 0.010249 | . 2017-01-09 0.000000 | -0.014286 | 0.009390 | -0.015942 | . ... ... | ... | ... | ... | . 2019-12-19 0.007371 | 0.008333 | -0.040000 | -0.007650 | . 2019-12-20 -0.024390 | 0.000000 | -0.013889 | 0.013216 | . 2019-12-23 0.007500 | 0.001653 | 0.032864 | 0.027174 | . 2019-12-26 0.014888 | -0.011551 | -0.017273 | -0.017989 | . 2019-12-27 -0.019560 | 0.035058 | -0.000925 | -0.019397 | . 725 rows × 4 columns . The mean of the returns is called the Expected Return. . Similarly, the Risk or Volatility is the standard deviation of the returns. . (This is different from the expected return and volatility of a portfolio, this is for a single stock) . returns.mean() . MEG 0.000370 MAXS -0.000830 JFC 0.000258 ALI 0.000626 dtype: float64 . returns.std() . MEG 0.019875 MAXS 0.018216 JFC 0.017439 ALI 0.016768 dtype: float64 . We&#39;ll only plot MAXS and MEG to emphasize that the return for MEG is more volatile. . returns[[&#39;MAXS&#39;,&#39;MEG&#39;]].plot(figsize=(12,5)) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f24189f4dd8&gt; . Expected Return and Risk of a Portfolio . Suppose your portfolio consists of returns $R_1, R_2, R_3, ... ,R_n$. Then, the expected return of a portfolio is given by: . $E(R) = w_1E(R_1) + w_2E(R_2) + w_3E(R_3) + ... + w_nE(R_n) $ . where $w_i$ is the $i$th component of an $n-dimensional$ vector, and $ Sigma w_i = 1.$ . weights = np.random.random(len(stocks)) weights /= np.sum(weights) weights . array([0.43575183, 0.25166811, 0.12249706, 0.190083 ]) . returns.mean() . MEG 0.000370 MAXS -0.000830 JFC 0.000258 ALI 0.000626 dtype: float64 . def calculate_portfolio_return(returns, weights): portfolio_return = np.sum(returns.mean()*weights)*252 print(&quot;Expected Portfolio Return:&quot;, portfolio_return) . calculate_portfolio_return(returns,weights) . Expected Portfolio Return: 0.025927802317915017 . If you had a course in Probability, you might recall that expectation of a random variable is linear while the variance is not. That&#39;s the same argument why the formula for the variance of a portfolio is quite more complicated. . $Var(R) = bf{w^{T}} Sigma textbf{w}$ . where $ Sigma$ is the covariance matrix of $R_i$ . returns.cov() . MEG MAXS JFC ALI . MEG 0.000395 | 0.000051 | 0.000066 | 0.000113 | . MAXS 0.000051 | 0.000332 | 0.000019 | 0.000046 | . JFC 0.000066 | 0.000019 | 0.000304 | 0.000082 | . ALI 0.000113 | 0.000046 | 0.000082 | 0.000281 | . np.sqrt(returns.cov()) . MEG MAXS JFC ALI . MEG 0.019875 | 0.007175 | 0.008150 | 0.010636 | . MAXS 0.007175 | 0.018216 | 0.004331 | 0.006803 | . JFC 0.008150 | 0.004331 | 0.017439 | 0.009034 | . ALI 0.010636 | 0.006803 | 0.009034 | 0.016768 | . returns.std() . MEG 0.019875 MAXS 0.018216 JFC 0.017439 ALI 0.016768 dtype: float64 . def calculate_portfolio_risk(returns, weights): portfolio_variance = np.sqrt(np.dot(weights.T, np.dot(returns.cov()*252,weights))) print(&quot;Expected Risk:&quot;, portfolio_variance) . calculate_portfolio_risk(returns,weights) . Expected Risk: 0.19906556027268363 . Sharpe Ratio . Remember, what we want is to find the best possible weight vector $ bf{w}$ that would give us the best possible return, with a minimal risk. Therefore, we will introduce a new metric called the sharpe ratio. It&#39;s simply equal to . $$S.R. = frac{E(R) - R_f}{ sqrt{Var(R)}}$$ . where $R_f$ is the risk free return. Since we&#39;re only limiting ourselves to risky assets (stocks) therefore, the formula becomes . $$S.R. = frac{E(R) - 0}{ sqrt{Var(R)}} = frac{E(R)}{ sqrt{Var(R)}}$$ . def generate_portfolios(weights, returns): preturns = [] pvariances = [] for i in range(10000): weights = np.random.random(len(stocks)) weights/=np.sum(weights) preturns.append(np.sum(returns.mean()*weights)*252) pvariances.append(np.sqrt(np.dot(weights.T,np.dot(returns.cov()*252,weights)))) preturns = np.array(preturns) pvariances = np.array(pvariances) return preturns,pvariances def plot_portfolios(returns, variances): plt.figure(figsize=(10,6)) plt.scatter(variances,returns,c=returns/variances,marker=&#39;o&#39;) plt.grid(True) plt.xlabel(&#39;Expected Volatility&#39;) plt.ylabel(&#39;Expected Return&#39;) plt.colorbar(label=&#39;Sharpe Ratio&#39;) plt.show() . preturns, pvariances = generate_portfolios(weights,returns) . Monte - Carlo Simulation . Here, we simulated 10,000 possible weight allocations, and computed their respective expected return, risk and sharpe ratio. . plot_portfolios(preturns, pvariances) . Finding the Optimal Weights . At a high level, we would want to run an optimization algorithm that would . $$maximize frac{E(R)-R_f}{ sqrt{Var(R)}}$$ . $$s.t. forall w_i, w_i geq0 and Sigma w_i=1$$ . Full details of the mathematics behind this can be found on resources. . def statistics(weights, returns): portfolio_return=np.sum(returns.mean()*weights)*252 portfolio_volatility=np.sqrt(np.dot(weights.T,np.dot(returns.cov()*252,weights))) return np.array([portfolio_return,portfolio_volatility,portfolio_return/portfolio_volatility]) def min_func_sharpe(weights,returns): return -statistics(weights,returns)[2] def optimize_portfolio(weights,returns): constraints = ({&#39;type&#39;:&#39;eq&#39;,&#39;fun&#39;: lambda x: np.sum(x)-1}) bounds = tuple((0,1) for x in range(len(stocks))) optimum=optimization.minimize(fun=min_func_sharpe,x0=weights,args=returns,method=&#39;SLSQP&#39;,bounds=bounds,constraints=constraints) return optimum def print_optimal_portfolio(optimum, returns): print(&quot;Optimal weights:&quot;, optimum[&#39;x&#39;].round(3)) print(&quot;Expected return, volatility and Sharpe ratio:&quot;, statistics(optimum[&#39;x&#39;].round(3),returns)) def show_optimal_portfolio(optimum, returns, preturns, pvariances): plt.figure(figsize=(10,6)) plt.scatter(pvariances,preturns,c=preturns/pvariances,marker=&#39;o&#39;) plt.grid(True) plt.xlabel(&#39;Expected Volatility&#39;) plt.ylabel(&#39;Expected Return&#39;) plt.colorbar(label=&#39;Sharpe Ratio&#39;) plt.plot(statistics(optimum[&#39;x&#39;],returns)[1],statistics(optimum[&#39;x&#39;],returns)[0],&#39;g*&#39;,markersize=20.0) plt.show() . optimum=optimize_portfolio(weights,returns) print_optimal_portfolio(optimum, returns) show_optimal_portfolio(optimum, returns, preturns, pvariances) . Optimal weights: [0.122 0. 0.09 0.788] Expected return, volatility and Sharpe ratio: [0.14160147 0.23423143 0.60453661] . returns.mean() . MEG 0.000370 MAXS -0.000830 JFC 0.000258 ALI 0.000626 dtype: float64 . Resources: . Financial Mathematics https://www.springer.com/gp/book/9780857290816 | . | General Investing https://www.ig.com/en/learn-to-trade/ig-academy | . | .",
            "url": "https://enzoampil.github.io/fastquant-blog/2020/05/29/markowitz_modern_portfolio.html",
            "relUrl": "/2020/05/29/markowitz_modern_portfolio.html",
            "date": " • May 29, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "backtesting with grid search using fastquant",
            "content": ". # uncomment to install in colab # !pip install git+https://github.com/enzoampil/fastquant.git@master#egg=fastquant . backtest SMAC . fastquant offers a convenient way to backtest several trading strategies. To backtest using Simple Moving Average Crossover (SMAC), we do the following. . backtest(&#39;smac&#39;, dcv_data, fast_period=15, slow_period=40) . fast_period and slow_period are two SMAC parameters that can be changed depending on the user&#39;s preferences. A simple way to fine tune these parameters is to run backtest on a grid of values and find which combination of fast_period and slow_period yields the highest net profit. . First, we fetch JFC&#39;s historical data comprised of date, close price, and volume. . from fastquant import get_stock_data, backtest symbol=&#39;JFC&#39; dcv_data = get_stock_data(symbol, start_date=&#39;2018-01-01&#39;, end_date=&#39;2020-04-28&#39;, format=&#39;cv&#39;, ) dcv_data.head() . 849it [04:08, 4.04it/s] . close volume . dt . 2018-01-03 255.4 | 745780 | . 2018-01-04 255.0 | 617010 | . 2018-01-05 255.0 | 946040 | . 2018-01-08 256.0 | 840630 | . 2018-01-09 255.8 | 978180 | . import matplotlib.pyplot as pl pl.style.use(&quot;default&quot;) . from fastquant import backtest results = backtest(&quot;smac&quot;, dcv_data, fast_period=15, slow_period=40, verbose=False, plot=True ) . ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== fast_period : 15 slow_period : 40 Final PnL: -31257.65 Time used (seconds): 0.10944700241088867 Optimal parameters: {&#39;init_cash&#39;: 100000, &#39;buy_prop&#39;: 1, &#39;sell_prop&#39;: 1, &#39;execution_type&#39;: &#39;close&#39;, &#39;fast_period&#39;: 15, &#39;slow_period&#39;: 40} Optimal metrics: {&#39;rtot&#39;: -0.37480465562458976, &#39;ravg&#39;: -0.0006645472617457265, &#39;rnorm&#39;: -0.15419454966091925, &#39;rnorm100&#39;: -15.419454966091925, &#39;sharperatio&#39;: -0.9821454406209409, &#39;pnl&#39;: -31257.65, &#39;final_value&#39;: 68742.35499999995} . The plot above is optional. backtest returns a dataframe of parameters and corresponding metrics: . results.head() . init_cash buy_prop sell_prop execution_type fast_period slow_period rtot ravg rnorm rnorm100 sharperatio pnl final_value . 0 100000 | 1 | 1 | close | 15 | 40 | -0.374805 | -0.000665 | -0.154195 | -15.419455 | -0.982145 | -31257.65 | 68742.355 | . define the search space . Second, we specify the range of reasonable values to explore for fast_period and slow_period. Let&#39;s take between 1 and 20 trading days (roughly a month) in steps of 1 day for fast_period, and between 21 and 240 trading days (roughly a year) in steps of 5 days for slow_period. . import numpy as np fast_periods = np.arange(1,20,1, dtype=int) slow_periods = np.arange(20,241,5, dtype=int) # make a grid of 0&#39;s (placeholder) period_grid = np.zeros(shape=(len(fast_periods),len(slow_periods))) period_grid.shape . (19, 45) . run grid search . Third, we run backtest for each iteration over each pair of fast_period and slow_period, saving each time the net profit to the period_grid variable. . Note: Before running backtest over a large grid, try measuring how long it takes your machine to run one backtest instance. . %timeit backtest(...) . In my machine with 8 cores, backtest takes . 101 ms ± 8.3 ms per loop (mean ± std. dev. of 7 runs, 10 loops each) . from time import time init_cash=100000 start_time = time() for i,fast_period in enumerate(fast_periods): for j,slow_period in enumerate(slow_periods): results = backtest(&#39;smac&#39;, dcv_data, fast_period=fast_period, slow_period=slow_period, init_cash=100000, verbose=False, plot=False ) net_profit = results.final_value.values[0]-init_cash period_grid[i,j] = net_profit end_time = time() . time_basic = end_time-start_time print(&quot;Basic grid search took {:.1f} sec&quot;.format(time_basic)) . Basic grid search took 100.4 sec . visualize the period grid . Next, we visualize period_grid as a 2D matrix. . import matplotlib.colors as mcolors import matplotlib.pyplot as pl pl.style.use(&quot;default&quot;) fig, ax = pl.subplots(1,1, figsize=(8,4)) xmin, xmax = slow_periods[0],slow_periods[-1] ymin, ymax = fast_periods[0],fast_periods[-1] #make a diverging color map such that profit&lt;0 is red and blue otherwise cmap = pl.get_cmap(&#39;RdBu&#39;) norm = mcolors.DivergingNorm(vmin=period_grid.min(), vmax = period_grid.max(), vcenter=0 ) #plot matrix cbar = ax.imshow(period_grid, origin=&#39;lower&#39;, interpolation=&#39;none&#39;, extent=[xmin, xmax, ymin, ymax], cmap=cmap, norm=norm ) pl.colorbar(cbar, ax=ax, shrink=0.9, label=&#39;net profit&#39;, orientation=&quot;horizontal&quot;) # search position with highest net profit y, x = np.unravel_index(np.argmax(period_grid), period_grid.shape) best_slow_period = slow_periods[x] best_fast_period = fast_periods[y] # mark position # ax.annotate(f&quot;max profit={period_grid[y, x]:.0f}@({best_slow_period}, {best_fast_period}) days&quot;, # (best_slow_period+5,best_fast_period+1) # ) ax.axvline(best_slow_period, 0, 1, c=&#39;k&#39;, ls=&#39;--&#39;) ax.axhline(best_fast_period+0.5, 0, 1, c=&#39;k&#39;, ls=&#39;--&#39;) # add labels ax.set_aspect(5) pl.setp(ax, xlim=(xmin,xmax), ylim=(ymin,ymax), xlabel=&#39;slow period (days)&#39;, ylabel=&#39;fast period (days)&#39;, title=&#39;JFC w/ SMAC&#39;, ); . print(f&quot;max profit={period_grid[y, x]:.0f} @ ({best_slow_period},{best_fast_period}) days&quot;) . max profit=7042 @ (105,3) days . From the plot above, there are only a few period combinations which we can guarantee non-negative net profit using SMAC strategy. The best result is achieved with (105,30) for period_slow and period_fast, respectively. . In fact SMAC strategy is so bad such that there is only 9% chance it will yield profit when using any random period combinations in our grid, which is smaller than the 12% chance it will yield break even at least. . percent_positive_profit=(period_grid&gt;0).sum()/np.product(period_grid.shape)*100 percent_positive_profit . 9.005847953216374 . percent_breakeven=(period_grid==0).sum()/np.product(period_grid.shape)*100 percent_breakeven . 12.397660818713451 . Anyway, let&#39;s check the results of backtest using the best_fast_period and best_slow_period. . results = backtest(&#39;smac&#39;, dcv_data, fast_period=best_fast_period, slow_period=best_slow_period, verbose=True, plot=True ) net_profit = results.final_value.values[0]-init_cash net_profit . Starting Portfolio Value: 100000.00 ===Global level arguments=== init_cash : 100000 buy_prop : 1 sell_prop : 1 ===Strategy level arguments=== fast_period : 3 slow_period : 105 2018-08-22, BUY CREATE, 286.00 2018-08-22, Cash: 100000.0 2018-08-22, Price: 286.0 2018-08-22, Buy prop size: 346 2018-08-22, Afforded size: 346 2018-08-22, Final size: 346 2018-08-23, BUY EXECUTED, Price: 286.00, Cost: 98956.00, Comm 742.17 2018-09-12, SELL CREATE, 277.00 2018-09-13, SELL EXECUTED, Price: 277.00, Cost: 98956.00, Comm 718.81 2018-09-13, OPERATION PROFIT, GROSS -3114.00, NET -4574.98 2018-10-23, BUY CREATE, 268.00 2018-10-23, Cash: 95425.015 2018-10-23, Price: 268.0 2018-10-23, Buy prop size: 353 2018-10-23, Afforded size: 353 2018-10-23, Final size: 353 2018-10-24, BUY EXECUTED, Price: 268.00, Cost: 94604.00, Comm 709.53 2018-10-25, SELL CREATE, 270.00 2018-10-26, SELL EXECUTED, Price: 270.00, Cost: 94604.00, Comm 714.83 2018-10-26, OPERATION PROFIT, GROSS 706.00, NET -718.36 2018-10-30, BUY CREATE, 264.00 2018-10-30, Cash: 94706.66 2018-10-30, Price: 264.0 2018-10-30, Buy prop size: 355 2018-10-30, Afforded size: 355 2018-10-30, Final size: 355 2018-10-31, BUY EXECUTED, Price: 264.00, Cost: 93720.00, Comm 702.90 2019-04-17, SELL CREATE, 303.00 2019-04-22, SELL EXECUTED, Price: 303.00, Cost: 93720.00, Comm 806.74 2019-04-22, OPERATION PROFIT, GROSS 13845.00, NET 12335.36 Final PnL: 7042.02 ================================================== ************************************************** -- {&#39;init_cash&#39;: 100000, &#39;buy_prop&#39;: 1, &#39;sell_prop&#39;: 1, &#39;execution_type&#39;: &#39;close&#39;, &#39;fast_period&#39;: 3, &#39;slow_period&#39;: 105} OrderedDict([(&#39;rtot&#39;, 0.06805130501900258), (&#39;ravg&#39;, 0.00012065834223227409), (&#39;rnorm&#39;, 0.03087288265827186), (&#39;rnorm100&#39;, 3.087288265827186)]) OrderedDict([(&#39;sharperatio&#39;, 0.7850452330792583)]) Time used (seconds): 0.11643362045288086 Optimal parameters: {&#39;init_cash&#39;: 100000, &#39;buy_prop&#39;: 1, &#39;sell_prop&#39;: 1, &#39;execution_type&#39;: &#39;close&#39;, &#39;fast_period&#39;: 3, &#39;slow_period&#39;: 105} Optimal metrics: {&#39;rtot&#39;: 0.06805130501900258, &#39;ravg&#39;: 0.00012065834223227409, &#39;rnorm&#39;: 0.03087288265827186, &#39;rnorm100&#39;: 3.087288265827186, &#39;sharperatio&#39;: 0.7850452330792583, &#39;pnl&#39;: 7042.02, &#39;final_value&#39;: 107042.0225} . 7042.022500000006 . There are only 6 cross-over events of which only the latest transaction yielded positive gains resulting to a 7% net profit. Is 7% profit over a ~two-year baseline better than the market benchmark? . built-in grid search in fastquant . The good news is backtest provides a built-in grid search if strategy parameters are lists. Let&#39;s re-run backtest with a grid we used above. . from fastquant import backtest start_time = time() results = backtest(&quot;smac&quot;, dcv_data, fast_period=fast_periods, slow_period=slow_periods, verbose=False, plot=False ) end_time = time() time_optimized = end_time-start_time . print(&quot;Optimized grid search took {:.1f} sec&quot;.format(time_optimized)) . Optimized grid search took 95.6 sec . results is automatically ranked based on rnorm which is a proxy for performance. In this case, the best fast_period,slow_period=(8,200) d. . The returned parameters are should have len(fast_periods)xlen(slow_periods) (19x45=855 in this case). . results.shape . (855, 13) . results.head() . init_cash buy_prop sell_prop execution_type fast_period slow_period rtot ravg rnorm rnorm100 sharperatio pnl final_value . 0 100000 | 1 | 1 | close | 3 | 105 | 0.068051 | 0.000121 | 0.030873 | 3.087288 | 0.785045 | 7042.02 | 107042.0225 | . 1 100000 | 1 | 1 | close | 8 | 205 | 0.037052 | 0.000066 | 0.016693 | 1.669276 | 0.085703 | 3774.66 | 103774.6555 | . 2 100000 | 1 | 1 | close | 11 | 170 | 0.037052 | 0.000066 | 0.016693 | 1.669276 | 0.085703 | 3774.66 | 103774.6555 | . 3 100000 | 1 | 1 | close | 8 | 200 | 0.037052 | 0.000066 | 0.016693 | 1.669276 | 0.085703 | 3774.66 | 103774.6555 | . 4 100000 | 1 | 1 | close | 9 | 95 | 0.033320 | 0.000059 | 0.014999 | 1.499897 | 0.092115 | 3388.12 | 103388.1175 | . Now, we recreate the 2D matrix before, but this time using scatter plot. . fig, ax = pl.subplots(1,1, figsize=(8,4)) #make a diverging color map such that profit&lt;0 is red and blue otherwise cmap = pl.get_cmap(&#39;RdBu&#39;) norm = mcolors.DivergingNorm(vmin=period_grid.min(), vmax = period_grid.max(), vcenter=0 ) #plot scatter results[&#39;net_profit&#39;] = results[&#39;final_value&#39;]-results[&#39;init_cash&#39;] df = results[[&#39;slow_period&#39;,&#39;fast_period&#39;,&#39;net_profit&#39;]] ax2 = df.plot.scatter(x=&#39;slow_period&#39;, y=&#39;fast_period&#39;, c=&#39;net_profit&#39;, norm=norm, cmap=cmap, ax=ax ) ymin,ymax = df.fast_period.min(), df.fast_period.max() xmin,xmax = df.slow_period.min(), df.slow_period.max() # best performance (instead of highest profit) best_fast_period, best_slow_period, net_profit = df.loc[0,[&#39;fast_period&#39;,&#39;slow_period&#39;,&#39;net_profit&#39;]] # mark position # ax.annotate(f&quot;max profit={net_profit:.0f}@({best_slow_period}, {best_fast_period}) days&quot;, # (best_slow_period-100,best_fast_period+1), color=&#39;r&#39; # ) ax.axvline(best_slow_period, 0, 1, c=&#39;r&#39;, ls=&#39;--&#39;) ax.axhline(best_fast_period+0.5, 0, 1, c=&#39;r&#39;, ls=&#39;--&#39;) ax.set_aspect(5) pl.setp(ax, xlim=(xmin,xmax), ylim=(ymin,ymax), xlabel=&#39;slow period (days)&#39;, ylabel=&#39;fast period (days)&#39;, title=&#39;JFC w/ SMAC&#39;, ); # fig.colorbar(ax2, orientation=&quot;horizontal&quot;, shrink=0.9, label=&#39;net profit&#39;) . print(f&quot;max profit={net_profit:.0f} @ ({best_slow_period},{best_fast_period}) days&quot;) . max profit=7042 @ (105.0,3.0) days . Note also that built-in grid search in backtest is optimized and slightly faster than the basic loop-based grid search. . #time time_basic/time_optimized . 1.0497938879462785 . Final notes . While it is tempting to do a grid search over larger search space and finer resolutions, it is computationally expensive, inefficient, and prone to overfitting. There are better methods than brute force grid search which we will tackle in the next example. . As an exercise, it is good to try the following: . Use different trading strategies and compare their results | Use a longer data baseline | .",
            "url": "https://enzoampil.github.io/fastquant-blog/2020/05/02/backtest_with_grid_search.html",
            "relUrl": "/2020/05/02/backtest_with_grid_search.html",
            "date": " • May 2, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "Installation",
            "content": ". # !pip install -e git+https://github.com/enzoampil/fastquant.git@master#egg=fastquant . Get stock data . from fastquant import get_stock_data df = get_stock_data(&#39;JFC&#39;, &#39;2018-01-01&#39;, &#39;2019-01-01&#39;) df.head() . close . dt . 2018-01-03 255.4 | . 2018-01-04 255.0 | . 2018-01-05 255.0 | . 2018-01-08 256.0 | . 2018-01-09 255.8 | . Plot daily closing prices . from matplotlib import pyplot as plt df.close.plot(figsize=(10, 6)) plt.title(&quot;Daily Closing Prices of JFC nfrom 2018-01-01 to 2019-01-01&quot;, fontsize=20) . Text(0.5, 1.0, &#39;Daily Closing Prices of JFC nfrom 2018-01-01 to 2019-01-01&#39;) . Analyze with a simple moving average (SMA) trading strategy . import pandas as pd ma30 = df.close.rolling(30).mean() close_ma30 = pd.concat([df.close, ma30], axis=1).dropna() close_ma30.columns = [&#39;Closing Price&#39;, &#39;Simple Moving Average (30 day)&#39;] close_ma30.plot(figsize=(10, 6)) plt.title(&quot;Daily Closing Prices vs 30 day SMA of JFC nfrom 2018-01-01 to 2019-01-01&quot;, fontsize=20) . Text(0.5, 1.0, &#39;Daily Closing Prices vs 30 day SMA of JFC nfrom 2018-01-01 to 2019-01-01&#39;) .",
            "url": "https://enzoampil.github.io/fastquant-blog/2020/04/13/fastquant_demo.html",
            "relUrl": "/2020/04/13/fastquant_demo.html",
            "date": " • Apr 13, 2020"
        }
        
    
  
    
        ,"post8": {
            "title": "Analyzing PSE disclosures data",
            "content": "# uncomment to install in colab # !pip install -e git+https://github.com/enzoampil/fastquant.git@master#egg=fastquant . from fastquant import DisclosuresPSE . fetching company disclosures . dpse = DisclosuresPSE(symbol=&#39;JFC&#39;, start_date=&#39;1-1-2020&#39;, end_date=&#39;5-1-2020&#39; ) . Pulling JFC disclosures summary... . 0%| | 0/12 [00:00&lt;?, ?it/s] . 1 pages detected! Found 12 disclosures between 1-1-2020 &amp; 5-1-2020 with 4 types: [&#39;Press Release&#39; &#39;Declaration of Cash Dividends&#39; &#39;Material Information/Transactions&#39; &#39;Joint Ventures&#39;] Pulling details in all JFC disclosures... . 100%|██████████| 12/12 [00:09&lt;00:00, 1.21it/s] . Saved: /home/prometheus/github/research/project/fastquant/python/fastquant/data/JFC_disclosures_1-1-2020_5-1-2020.csv . . dpse . DisclosuresPSE(&#39;JFC&#39;, &#39;all&#39;, &#39;1-1-2020&#39;, &#39;5-1-2020&#39;, True, False) . # summary of each disclosure dpse.company_disclosures.head() . Company Name Template Name PSE Form Number Announce Date and Time Circular Number edge_no url . 0 Jollibee Foods Corporation | Press Release | 4-31 | 2020-04-15 07:41:00 | C02771-2020 | 2fd88ba354823b280de8473cebbd6407 | https://edge.pse.com.ph/openDiscViewer.do?edge... | . 1 Jollibee Foods Corporation | Declaration of Cash Dividends | 6-1 | 2020-04-07 10:16:00 | C02610-2020 | 4b9121b34dd8b8e80de8473cebbd6407 | https://edge.pse.com.ph/openDiscViewer.do?edge... | . 2 Jollibee Foods Corporation | Press Release | 4-31 | 2020-03-20 07:16:00 | C02127-2020 | a5df62b1a9558fe60de8473cebbd6407 | https://edge.pse.com.ph/openDiscViewer.do?edge... | . 3 Jollibee Foods Corporation | Press Release | 4-31 | 2020-03-19 07:31:00 | C02092-2020 | 6a7705d00b3e6fb50de8473cebbd6407 | https://edge.pse.com.ph/openDiscViewer.do?edge... | . 4 Jollibee Foods Corporation | Material Information/Transactions | 4-30 | 2020-03-16 12:49:00 | C01925-2020 | 5b6a51f239ad5a6f0de8473cebbd6407 | https://edge.pse.com.ph/openDiscViewer.do?edge... | . # includes details dpse.disclosures_combined.head() . Company Name Template Name PSE Form Number Announce Date and Time Circular Number edge_no url disclosure_table Background/Description of the Disclosure Subject of the Disclosure . 0 Jollibee Foods Corporation | Press Release | 4-31 | 2020-04-15 07:41:00 | C02771-2020 | 2fd88ba354823b280de8473cebbd6407 | https://edge.pse.com.ph/openDiscViewer.do?edge... | {&quot;Title of Each Class&quot;: &quot;Common&quot;, &quot;Subject of ... | JFC Reports 2019 Results Based on Audited Fina... | Press Release: 2019 Audited Financial Results | . 1 Jollibee Foods Corporation | Declaration of Cash Dividends | 6-1 | 2020-04-07 10:16:00 | C02610-2020 | 4b9121b34dd8b8e80de8473cebbd6407 | https://edge.pse.com.ph/openDiscViewer.do?edge... | {&quot;Title of Each Class&quot;: &quot;Common&quot;, &quot;Subject of ... | Jollibee Foods Corporation (JFC) announced tod... | JFC Declares Cash Dividend, Delivery Business ... | . 2 Jollibee Foods Corporation | Press Release | 4-31 | 2020-03-20 07:16:00 | C02127-2020 | a5df62b1a9558fe60de8473cebbd6407 | https://edge.pse.com.ph/openDiscViewer.do?edge... | {&quot;Title of Each Class&quot;: &quot;Common&quot;, &quot;Subject of ... | Jollibee Foods Corporation (JFC) Chairman and ... | Jollibee Group allocates Php1 Billion Emergenc... | . 3 Jollibee Foods Corporation | Press Release | 4-31 | 2020-03-19 07:31:00 | C02092-2020 | 6a7705d00b3e6fb50de8473cebbd6407 | https://edge.pse.com.ph/openDiscViewer.do?edge... | {&quot;Title of Each Class&quot;: &quot;Common&quot;, &quot;Subject of ... | In support of health workers and other frontli... | Jollibee Group Donates Php 100 Million worth o... | . 4 Jollibee Foods Corporation | Material Information/Transactions | 4-30 | 2020-03-16 12:49:00 | C01925-2020 | 5b6a51f239ad5a6f0de8473cebbd6407 | https://edge.pse.com.ph/openDiscViewer.do?edge... | {&quot;Title of Each Class&quot;: &quot;Common&quot;, &quot;Subject of ... | This provides a brief summary for Jollibee Foo... | Risks, Impact on the Business and Mitigation M... | . #get details in each disclosure given edge_no dpse.disclosure_tables[&#39;a5df62b1a9558fe60de8473cebbd6407&#39;].shape . (6, 2) . dpse.disclosures_combined[&#39;Subject of the Disclosure&#39;] . 0 Press Release: 2019 Audited Financial Results 1 JFC Declares Cash Dividend, Delivery Business ... 2 Jollibee Group allocates Php1 Billion Emergenc... 3 Jollibee Group Donates Php 100 Million worth o... 4 Risks, Impact on the Business and Mitigation M... 5 Jollibee Foods Corporation (JFC) and Dim Sum P... 6 Results of the 4th Quarter Unaudited Financial... 7 Press Release: 2019 4th Quarter Financial Results 8 JFC Provides Statement on Business in China 9 JFC to Issue US$600 Million Guaranteed Senior ... 10 JFC to Issue US$600 Million Guaranteed Senior ... 11 JFC Mandates Banks for U.S.$ Senior Guaranteed... Name: Subject of the Disclosure, dtype: object . dpse.disclosures_combined[&#39;Background/Description of the Disclosure&#39;] . 0 JFC Reports 2019 Results Based on Audited Fina... 1 Jollibee Foods Corporation (JFC) announced tod... 2 Jollibee Foods Corporation (JFC) Chairman and ... 3 In support of health workers and other frontli... 4 This provides a brief summary for Jollibee Foo... 5 Golden Plate Pte. Ltd. (GPPL), a wholly owned ... 6 4th Quarter Unaudited Financial Statements for... 7 JFC Same Store Sales Growth Improves, Gains fr... 8 Jollibee Foods Corporation makes the following... 9 Jollibee Foods Corporation (JFC, the “Guaranto... 10 Jollibee Foods Corporation (JFC, the “Guaranto... 11 Jollibee Worldwide Pte. Ltd. (JWPL, the “Issue... Name: Background/Description of the Disclosure, dtype: object . visualization . dpse.disclosure_types . array([&#39;Press Release&#39;, &#39;Declaration of Cash Dividends&#39;, &#39;Material Information/Transactions&#39;, &#39;Joint Ventures&#39;], dtype=object) . #all disclosures superposed with percent change fig = dpse.plot_disclosures() . Pulling JFC stock data... . #all disclosures superposed with close price fig = dpse.plot_disclosures(indicator=&#39;close&#39;, diff=False, percent=False) . filtering disclosures . #disclosures co-incident with max percent change maximum = dpse.filter_disclosures() maximum . Company Name Template Name PSE Form Number Announce Date and Time Circular Number edge_no url disclosure_table Background/Description of the Disclosure Subject of the Disclosure . 5 Jollibee Foods Corporation | [Amend-1]Joint Ventures | 4-22 | 2020-03-13 15:49:00 | C01685-2020 | 21b9a26e7aa00f960de8473cebbd6407 | https://edge.pse.com.ph/openDiscViewer.do?edge... | {&quot;Title of Each Class&quot;: &quot;COMMON&quot;, &quot;Subject of ... | Golden Plate Pte. Ltd. (GPPL), a wholly owned ... | Jollibee Foods Corporation (JFC) and Dim Sum P... | . #disclosures co-incident with min percent change minimum = dpse.filter_disclosures(operation=&#39;min&#39;) minimum . Company Name Template Name PSE Form Number Announce Date and Time Circular Number edge_no url disclosure_table Background/Description of the Disclosure Subject of the Disclosure . 0 Jollibee Foods Corporation | Press Release | 4-31 | 2020-04-15 07:41:00 | C02771-2020 | 2fd88ba354823b280de8473cebbd6407 | https://edge.pse.com.ph/openDiscViewer.do?edge... | {&quot;Title of Each Class&quot;: &quot;Common&quot;, &quot;Subject of ... | JFC Reports 2019 Results Based on Audited Fina... | Press Release: 2019 Audited Financial Results | . #what happened then? maximum[&#39;Background/Description of the Disclosure&#39;].values . array([&#39;Golden Plate Pte. Ltd. (GPPL), a wholly owned subsidiary of JFC, and DSPL executed a Joint Venture Agreement to establish a joint venture company (the “JV”) to be incorporated in the People’s Republic of China (PRC). The JV shall sign a Unit Franchise Agreement with Tim Ho Wan Pte. Ltd. (“Franchisor”), authorized master franchisor of Tim Ho Wan in the Asia-Pacific, to develop and operate Tim Ho Wan stores in Shanghai and such other cities within the PRC as may be agreed with the Franchisor.&#39;], dtype=object) . #details maximum[&#39;Subject of the Disclosure&#39;].values . array([&#39;Jollibee Foods Corporation (JFC) and Dim Sum Pte. Ltd. (DSPL) Signs Agreement to Expand and Operate the Tim Ho Wan Brand in China.&#39;], dtype=object) . #get url maximum[&#39;url&#39;].values . array([&#39;https://edge.pse.com.ph/openDiscViewer.do?edge_no=21b9a26e7aa00f960de8473cebbd6407&#39;], dtype=object) . #what happened during minimum? minimum[&#39;Background/Description of the Disclosure&#39;].values . array([&#39;JFC Reports 2019 Results Based on Audited Financial Statements&#39;], dtype=object) . #details minimum[&#39;Subject of the Disclosure&#39;].values . array([&#39;Press Release: 2019 Audited Financial Results&#39;], dtype=object) . #get url minimum[&#39;url&#39;].values . array([&#39;https://edge.pse.com.ph/openDiscViewer.do?edge_no=2fd88ba354823b280de8473cebbd6407&#39;], dtype=object) . Investagrams disclosures . from fastquant import DisclosuresInvestagrams . dinv = DisclosuresInvestagrams(symbol=&#39;JFC&#39;, from_date=&#39;2018-01-01&#39;, to_date=&#39;2020-04-01&#39;) . dinv.dividends . id time color label Cash Dividends Ex-Date Record Date Payment Date . 0 timediv607 | 2018-04-19 | #0496FF | D | 1.14 | Thu Apr 19, 2018 | Tue Apr 24, 2018 | Wed May 09, 2018 | . 1 timediv786 | 2018-11-21 | #0496FF | D | 1.34 | Wed Nov 21, 2018 | Mon Nov 26, 2018 | Mon Dec 10, 2018 | . 2 timediv934 | 2019-04-23 | #0496FF | D | 1.23 | Tue Apr 23, 2019 | Fri Apr 26, 2019 | Thu May 09, 2019 | . 3 timediv1112 | 2019-11-21 | #0496FF | D | 1.35 | Thu Nov 21, 2019 | Tue Nov 26, 2019 | Tue Dec 10, 2019 | . dinv.earnings . id time color label Total Revenue Net Income EPS Date Period Ending Revenue Unit NI Unit Net Income Amount Net Income YoY Growth (%) . 0 timeearnings4820175 | 2018-04-11 06:26:00 | #DC143C | E | 133.39 | 6.67B (10.23%) | 6.58 | Wed Apr 11, 2018 | Dec 31, 2017 | B | B (%) | 6.67 | 10.23 | . 1 timeearnings4820181 | 2018-05-10 00:32:00 | #DC143C | E | 35.05 | 1.67B (13.14%) | 1.66 | Thu May 10, 2018 | Mar 31, 2018 | B | B (%) | 1.67 | 13.14 | . 2 timeearnings4820182 | 2018-08-14 01:21:00 | #DC143C | E | 40.78 | 2.1B (10.55%) | 2.07 | Tue Aug 14, 2018 | Jun 30, 2018 | B | B (%) | 2.10 | 10.55 | . 3 timeearnings4820183 | 2018-11-12 05:18:00 | #DC143C | E | 40.49 | 1.93B (26.90%) | 1.87 | Mon Nov 12, 2018 | Sep 30, 2018 | B | B (%) | 1.93 | 26.90 | . 4 timeearnings4820185 | 2019-04-11 00:33:00 | #DC143C | E | 164.35 | 7.77B (16.47%) | 7.66 | Thu Apr 11, 2019 | Dec 31, 2018 | B | B (%) | 7.77 | 16.47 | . 5 timeearnings4820191 | 2019-05-15 06:37:00 | #DC143C | E | 40.62 | 1.43B (-14.06%) | 1.41 | Wed May 15, 2019 | Mar 31, 2019 | B | B (-%) | 1.43 | -14.06 | . 6 timeearnings4820192 | 2019-08-05 07:13:00 | #DC143C | E | 44.22 | 985.48M (-53.10%) | 1.03 | Mon Aug 05, 2019 | Jun 30, 2019 | B | M (-%) | 985.48 | -53.10 | . 7 timeearnings4820193 | 2019-11-14 03:46:00 | #DC143C | E | 45.17 | 2.01B (4.48%) | 1.71 | Thu Nov 14, 2019 | Sep 30, 2019 | B | B (%) | 2.01 | 4.48 | . disclosures-based strategy (under development) . !pip install backtrader[plotting]import pandas as pd from fastquant import backtest df = pd.read_csv(&quot;../data/JFC_20180101_20190110_DCV.csv&quot;) backtest(&#39;smac&#39;, df, fast_period=15, slow_period=40) from fastquant import BaseStrategy, DisclosuresPSE class DisclosuresStrategy(BaseStrategy): &quot;&quot;&quot; Disclosure-based trading strategy Parameters - &quot;&quot;&quot; params = ( (&quot;fast_period&quot;, 10), # period for the fast moving average (&quot;slow_period&quot;, 30), ) def __init__(self): # Initialize global variables super().__init__() # Strategy level variables self.fast_period = self.params.fast_period self.slow_period = self.params.slow_period print(&quot;===Strategy level arguments===&quot;) print(&quot;fast_period :&quot;, self.fast_period) print(&quot;slow_period :&quot;, self.slow_period) sma_fast = bt.ind.SMA(period=self.fast_period) # fast moving average sma_slow = bt.ind.SMA(period=self.slow_period) # slow moving average self.crossover = bt.ind.CrossOver( sma_fast, sma_slow ) # crossover signal def buy_signal(self): return self.crossover &gt; 0 def sell_signal(self): return self.crossover &lt; 0 . cols = &quot;datetime open high low close volume openinterest&quot;.split() def parse_data_format(format): data_format = {} for n,col in enumerate(cols): for f in format: if col[0]==f: data_format[col] = n else: data_format[col] = None return data_format DATA_FORMAT_MAPPING= {&quot;dcv&quot;: { &quot;datetime&quot;: 0, &quot;open&quot;: None, &quot;high&quot;: None, &quot;low&quot;: None, &quot;close&quot;: 1, &quot;volume&quot;: 2, &quot;openinterest&quot;: None}, &quot;dohlc&quot;: { &quot;datetime&quot;: 0, &quot;open&quot;: 1, &quot;high&quot;: 2, &quot;low&quot;: 3, &quot;close&quot;: 4, &quot;volume&quot;: None, &quot;openinterest&quot;: None } } . from fastquant import get_stock_data data = get_stock_data(&quot;JFC&quot;, start_date=&quot;2019-01-01&quot;, end_date=&quot;2020-01-01&quot;, format=&quot;dohlc&quot; ) data.head() . dt open high low close . 2077 2019-01-02 | 292.0 | 295.8 | 291.8 | 293.0 | . 2078 2019-01-03 | 292.8 | 294.2 | 290.8 | 292.0 | . 2079 2019-01-04 | 293.8 | 310.4 | 293.2 | 309.0 | . 2080 2019-01-07 | 309.0 | 324.2 | 309.0 | 323.0 | . 2081 2019-01-08 | 323.0 | 323.0 | 316.0 | 321.0 | . from datetime import datetime import pandas as pd import backtrader as bt import backtrader.feeds as btfeed from fastquant import DATA_FILE, COMMISSION_PER_TRANSACTION, INIT_CASH from fastquant import STRATEGY_MAPPING cerebro = bt.Cerebro(stdstats=False) # cerebro.addobserver(bt.observers.Broker) # cerebro.addobserver(bt.observers.Trades) # cerebro.addobserver(bt.observers.BuySell) cerebro.addstrategy(DisclosuresStrategy, #STRATEGY_MAPPING[&quot;rsi&quot;], init_cash=INIT_CASH) cerebro.broker.setcommission(commission=COMMISSION_PER_TRANSACTION) pd_data = bt.feeds.PandasData(dataname=data, fromdate=datetime(2019, 1, 1), todate=datetime(2020, 1, 1), **DATA_FORMAT_MAPPING[&quot;dohlc&quot;] ) cerebro.adddata(pd_data) cerebro.broker.setcash(INIT_CASH) # Allows us to set buy price based on next day closing # (technically impossible, but reasonable assuming you use all your money to buy market at the end of the next day) cerebro.broker.set_coc(True) print(&quot;Starting Portfolio Value: %.2f&quot; % cerebro.broker.getvalue()) cerebro.run() print(&quot;Final Portfolio Value: %.2f&quot; % cerebro.broker.getvalue()) # fig = pl.figure(figsize=(20, 10)) # cerebro.plot()",
            "url": "https://enzoampil.github.io/fastquant-blog/disclosures/2020/04/10/disclosures.html",
            "relUrl": "/disclosures/2020/04/10/disclosures.html",
            "date": " • Apr 10, 2020"
        }
        
    
  
    
        ,"post9": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://enzoampil.github.io/fastquant-blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About fastquant",
          "content": "Mission: . To promote data driven investments by making quantitative analysis in finance accessible to everyone. . Objectives . 1) Raise awareness, and guide beginners to get a sufficient foundation by teaching the basics of quant analysis with lessons &amp; tutorials presented via blog posts &amp; online lectures . 2) Make quant analysis simple and easy w/ a high level python API that allows for lower level configuration for more advanced users - development of an easy to use python package to facilitate data driven investments .",
          "url": "https://enzoampil.github.io/fastquant-blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://enzoampil.github.io/fastquant-blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}